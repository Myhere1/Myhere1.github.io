{"pages":[{"title":"about","text":"Myhere1 关于作者 90后，大四在读 联系方式 微信: xu6980584 博客: https://myhere1.github.io/ 扫码添加作者","link":"/about/index.html"}],"posts":[{"title":"Mybatis延迟加载和缓存","text":"Mybatis中的延迟加载延迟加载的引入引入问题:在一对多中，当我们有一个用户，它有100个账户。 在查询用户的时候要不要把所有的账户都查询出来？ 在查询账户的时候，要不要把关联的用户查出来？&nbsp; 在查询用户时，用户下的账户信息应当是，什么时候用，什么时候查询出来 在查询账户时，账户所属的用户信息应当是随着账户查询时一起查询出来 什么是延迟加载？在真正使用数据时，才发起查询。按需加载(懒加载) 什么是立即加载？不管有没有使用到，只要一调用方法，马上发起查询 在对应的四种表关系中：一对多，多对一，一对一，多对多一对多、多对多 : 一般采取延迟加载 一对一、多对一 : 一般采用立即加载 开启延迟加载在主配置文件SqlMapConfig.xml中1234567&lt;!--配置参数--&gt; &lt;settings&gt; &lt;!--开启Mybatis延迟加载的全局开关--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--每个属性都会按需加载 可以不配 默认值就是false--&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"&gt;&lt;/setting&gt; &lt;/settings&gt; 在AccountMapper.xml中1234567891011&lt;resultMap id=\"accountUserMap\" type=\"account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!--1对1关系映射,配置封装user内容 column设置为从表中的外键--&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"user\" select=\"com.xushui.dao.UserMapper.findById\"&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findAll\" resultMap=\"accountUserMap\" &gt; select * from account a&lt;/select&gt; 在UserMapper.xml中123&lt;select id=\"findById\" parameterType=\"Integer\" resultType=\"User\"&gt; select * from user where id = #{id}&lt;/select&gt; 当只执行，不需要用到用户信息时，使用了延迟加载1234@Test public void testFindAll() { List&lt;Account&gt; accounts = accountMapper.findAll(); } 在日志信息中可以看到1232019-07-31 10:34:20,357 723 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Preparing: select * from account a 2019-07-31 10:34:20,392 758 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Parameters: 2019-07-31 10:34:20,477 843 [ main] DEBUG shui.dao.AccountMapper.findAll - &lt;== Total: 3 若需要用户信息时12345678@Testpublic void testFindAll() { List&lt;Account&gt; accounts = accountMapper.findAll(); for (Account account : accounts) { System.out.println(account); System.out.println(account.getUser()); }} 在日志中可以看到对用户信息发起了查询1234567891011121314152019-07-31 10:44:13,182 635 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Preparing: select * from account a 2019-07-31 10:44:13,229 682 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Parameters: 2019-07-31 10:44:13,285 738 [ main] DEBUG shui.dao.AccountMapper.findAll - &lt;== Total: 32019-07-31 10:44:13,286 739 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Preparing: select * from user where id = ? 2019-07-31 10:44:13,286 739 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Parameters: 41(Integer)2019-07-31 10:44:13,295 748 [ main] DEBUG xushui.dao.UserMapper.findById - &lt;== Total: 1Account{id=1, uid=41, money=1000.0}User{id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;}2019-07-31 10:44:13,295 748 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Preparing: select * from user where id = ? 2019-07-31 10:44:13,295 748 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Parameters: 45(Integer)2019-07-31 10:44:13,297 750 [ main] DEBUG xushui.dao.UserMapper.findById - &lt;== Total: 1Account{id=2, uid=45, money=1000.0}User{id=45, username=&apos;传智播客&apos;, birthday=Sun Mar 04 12:04:06 CST 2018, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;}Account{id=3, uid=41, money=2000.0}User{id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;} Mybatis中的缓存什么是缓存？存在内存中的临时数据，比如说在第一次查询之后，就将其存储在内存，下一次要使用时，就不需要再去数据库查询，减少与数据库交互的次数，从而提高执行效率。 为什么使用缓存？减少和数据库交互次数，提高执行效率。 什么样的数据能使用缓存，什么样的数据不能使用？- 适用于缓存 - 使用频率高的数据 - 不经常改变的数据 - 数据的正确与否对最终效果影响不大的数据 - 不适用缓存的 - 经常改变的数据 - 数据的正确与否对最终结果影响很大的数据 - 例:商品的库存，银行的汇率，股市的牌价 Mybatis中的一级缓存和二级缓存一级缓存- 它指的是Mybatis中SqlSession对象的缓存 - 当我们执行查询之后，查询结果会同时存入到SqlSession为我们提供的一片区域中 - 结构是一种Map，当我们再次查询同样的数据，Mybatis会先从SqlSession中查询是否有，有的话就可以直接使用 - 当Sqlsession对象消失时，mybatis中的一级缓存就消失了 示范:12345678@Test public void testFirstCache(){ User user1 = userMapper.findById(41); System.out.println(user1); User user2 = userMapper.findById(41); System.out.println(user2); System.out.println(user1 == user2); } 日志中，可以看出只查询了一次，第二次是从缓存中取出。不过必须要确保SqlSession对象是同一个对象，没有消失，如果消失了，或者使用了clearCache()方法，缓存会被清空，就要重新查询。 1234562019-07-31 11:44:29,587 607 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Preparing: select * from user where id = ? 2019-07-31 11:44:29,618 638 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Parameters: 41(Integer)2019-07-31 11:44:29,647 667 [ main] DEBUG xushui.dao.UserMapper.findById - &lt;== Total: 1com.xushui.domain.User@e720b71com.xushui.domain.User@e720b71true 一级缓存的分析一级缓存是SqlSession范围的缓存，当调用SqlSession的修改，添加，删除，commit()，close()方法时，会清空一级缓存 二级缓存它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象所生产的SqlSession所共享的缓存 二级缓存的使用步骤 让Mybatis框架支持二级缓存(在SqlMapConfig.xml中配置) 1234&lt;settings&gt; &lt;!--全局开启缓存，默认为true--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 让当前的映射文件支持二级缓存(在UserMapper.xml中配置) 12&lt;!--开启UserMapper支持二级缓存--&gt; &lt;cache/&gt; 让当前的操作支持二级缓存(在当前操作的标签上配置useCache为true) 123&lt;select id=\"findById\" parameterType=\"Integer\" resultType=\"User\" useCache=\"true\"&gt; select * from user where id = #{id}&lt;/select&gt;","link":"/2019/07/30/Mybatis延迟加载和缓存/"},{"title":"Mybatis基于注解开发","text":"使用Mybatis注解实现基本的CRUD环境搭建SqlMapConfig.xml的配置123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--引入外部配置文件--&gt; &lt;properties resource=\"jdbcConfig.properties\"&gt; &lt;/properties&gt; &lt;!--配置别名--&gt; &lt;typeAliases&gt; &lt;!--配置的是实体类所在位置--&gt; &lt;package name=\"com.xushui.domain\"&gt;&lt;/package&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;environment id=\"mysql\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"&gt;&lt;/property&gt; &lt;property name=\"password \" value=\"${jdbc.password}\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定带有注解的dao接口所在位置--&gt; &lt;mappers&gt; &lt;!--配置的是dao所在位置--&gt; &lt;package name=\"com.xushui.dao\"&gt;&lt;/package&gt; &lt;/mappers&gt;&lt;/configuration&gt; 在接口方法的上方直接写上注解，一共有四种注解@Select、@Insert、@Update、Delete 12345678public interface UserMapper { /** * 查询所有用户 * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll();} 测试代码:12345678910111213141516171819public static void main(String[] args) throws Exception{ // 1.获取字节输入流 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 2.根据字节输入流构建SqlSessionFactory SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); // 3.根据SqlSessionFactory生产一个SqlSession SqlSession sqlSession = factory.openSession(); // 4.根据SqlSession获取Dao的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 5.执行dao的方法 List&lt;User&gt; users = userMapper.findAll(); for (User user : users) { System.out.println(user); } // 6.释放资源 sqlSession.close(); in.close(); } 需要注意的事项如果采用了注解开发的形式就不能再在resources中对应目录下写xml，否则就会报错 Mybatis注解开发单表CRUD常用操作示范代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public interface UserMapper { /** * 查询所有用户 * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll(); /** * 保存用户 * @param user */ @Insert(\"insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address})\") void saveUser(User user); /** * 修改user * @param user */ @Update(\"update user set username=#{username},sex=#{sex},address=#{address},birthday=#{birthday} where id=#{id}\") void updateUser(User user); /** * 根据id删除user * @param id */ @Delete(\"delete from user where id = #{id}\") void deleteUser(Integer id); /** * 通过id查找用户 * @param id * @return */ @Select(\"select * from user where id = #{id}\") User findUserById(Integer id); /** * 根据用户名称模糊查询 * @param name * @return */ @Select(\"select * from user where username like #{name}\") List&lt;User&gt; findUserByName(String name); /** * 查询用户总量 * @return */ @Select(\"select count(*) from user\") Integer findTotal();} 多表查询(一对一)用注解的方式解决数据库列名和对象的成员变量名不一致的问题在Mapper中添加注解12345678910111213141516171819202122/** * 查询所有用户 * @return */@Select(\"select * from user\")@Results(id = \"userMap\", value = { @Result(id = true, property = \"userId\", column = \"id\"), @Result(property = \"userName\", column = \"username\"), @Result(property = \"userBirthday\", column = \"birthday\"), @Result(property = \"userSex\", column = \"sex\"), @Result(property = \"userAddress\", column = \"address\")})List&lt;User&gt; findAll();/** * 通过id查找用户 * @param id * @return */@Select(\"select * from user where id = #{id}\")@ResultMap(value = {\"userMap\"})User findUserById(Integer id); 可以通过在定义Map时给id赋值，这样子在下面就可以直接用注解@ResultMap(value = {&quot;userMap&quot;})来复用，这个注解中可以添加多个map，当只有一个时，可以简写成@ResultMap(&quot;userMap&quot;) 第一步若是一对一的关系在一个对象中添加另一个对象作为成员变量例如:123456789public class Account implements Serializable { private Integer id; private Integer uid; private Integer money; // 一对一的映射 private User user; ......} 第二步在方法上添加注解123456789101112131415public interface AccountMapper { /** * 查询所有账户，并且获得每个账户所属的用户信息 * @return */ @Select(\"select * from account\") @Results(id = \"accountMap\", value = { @Result(id = true, property = \"id\", column = \"id\"), @Result(property = \"uid\", column = \"uid\"), @Result(property = \"money\", column = \"money\"), // property 表示要封装成什么 | column 表示用什么字段去查 | select 表示指向什么方法 | fetchType表示要选择什么方式加载(lazy延迟加载、eager立即加载) @Result(property = \"user\", column = \"uid\", one = @One(select = \"com.xushui.dao.UserMapper.findUserById\",fetchType = FetchType.EAGER)) }) List&lt;Account&gt; findAll();} 其中最后的@Result()注解中 property: 表示要封装成什么类型的数据 column: 表示要用什么字段去将你要封装的数据查询出来 one: 表示了一对一的注解 select: 表示了你要使用查询方法的全限定类名加方法名 fetchType: 取值有LAZY(延迟加载), EAGER(立即加载), DEFAULT(默认) 多表查询(一对多)第一步若是一对多关系则在一个对象中添加另一个对象的集合1234567891011public class User implements Serializable { private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; // 一对多关系映射 List&lt;Account&gt; accounts; ......} 第二步为AccountMapper添加一个方法1234567/** * 根据用户id查询账户信息 * @param uid * @return */@Select(\"select * from account where uid = #{uid}\")List&lt;Account&gt; findByUid(Integer uid); 第三步给UserMapper添加注解1234567891011121314/** * 查询所有用户，并获取每个用户的所有账户信息 * @return */@Select(\"select * from user\")@Results(id = \"userMap\", value = { @Result(id = true, property = \"userId\", column = \"id\"), @Result(property = \"userName\", column = \"username\"), @Result(property = \"userBirthday\", column = \"birthday\"), @Result(property = \"userSex\", column = \"sex\"), @Result(property = \"userAddress\", column = \"address\"), @Result(property = \"accounts\", column = \"id\", many = @Many(select = \"com.xushui.dao.AccountMapper.findByUid\", fetchType = FetchType.LAZY))})List&lt;User&gt; findAll(); 关于缓存的配置一级缓存在注解配置中是默认可以使用的二级缓存则需要在Mapper上方添加@CacheNamespace(blocking = true)，就可以使用了","link":"/2019/07/31/Mybatis基于注解开发/"},{"title":"MySQL必知必会 读书笔记","text":"第一章 了解SQL数据库概念​ 数据库是一种以某种有组织的方式存储的数据集合 主键的条件 任意两行都不惧有相同的主键值 每个行都必须具有一个主键值(不允许存在null) 好习惯 不更新主键列中的值 不重用主键列中的值 不再主键列中使用可能会更改的值 第三章 使用MySQL 显示表列 show columns from 表名;(describe 表名) 自增 auto_increment 显示建表语句 show create table 表名; 显示建数据库语句 show create database 数据库名; 第四章 索引数据 去处重复 select DISTINCT 列名 from 表名 DISTINCT作用于后面的所有列，使用了这个关键字除非后面的列都相等，否则会全部都索引出来。 限制结果 select 列名 from 表名 limit 5; 表示返回前5行 为了得出下一个五行 select 列名 from 表名 limit 5,5; 从第五行开始往后索引5条记录 第五章 排序索引数据 关系数据库设计理论认为，如果不能明确规定排序顺序，则不应该假定索引出的数据的顺序有意义。 数据排序 select 列名 from 表名 order by 列名; 在where关键字之后使用 可以使用非索引的列作为排序的依据 也可以用多个列作为排序的依据，按代码的顺序，来决定主次，如果主列中的值都是唯一的，则不会用次列的值排序 数据逆序排列 select 列名 from 表名 order by 列名 DESC; 在需要逆序排列的列名后加上DESC关键字 正序是ASC，是默认值 第六章 过滤数据第七章 数据过滤 在where之后and的优先级比or要高，所以在多条件组合时要注意，尽量用括号来解决。 IN ()用来指定条件范围，范围中的每个条件都可以进行匹配 IN的优点 语法更清除直观 计算次序更容易管理 IN操作符比OR操作符清单执行更快 IN的可以包含其他select语句，能够动态的建立Where子句 NOT操作符否定之后所跟的任何条件 MySQL支持对IN、BETWEEN、EXISTS子句取反 第八章 用通配符进行过滤 % 表示任何字符出现任意次数(甚至是0次) 但是%通配符不能匹配null _ 表示任何字符出现一次 关于通配符的技巧 通配符会让搜索时间变长 不要过度使用通配符，如果其他操作可以达到相同的目的，就应该使用其他操作符 确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据 第九章 用正则表达式进行搜索 MySQL正则表达式 REGEXP 与 like用法一致，后面跟的是正则表达式 MySQL中的正则表达式匹配不区分大小写，为区分大小写，可以使用BINARY关键字，如:where 列名 REGEXP BINARY ‘字符串’; 比起LIKE匹配整串而REGEXP匹配子串 正则表达式 . 表示任意一个字符 | 表示或 [和] [123]表示1或2或3，可以理解为[1|2|3] 可以用^来取反 [^123]就匹配除这些字符以外的字符 [0-9] 匹配数字0-9 [a-z] 匹配所有的字母 当需要匹配特殊符号时 采用加\\(两个反斜杠)的方式来区分\\.表示. 下面的标示用来标示前面一个字符 - : 表示0个或多个匹配 + : 表示1个或多个匹配 ? : 表示0个或1个匹配 {n} : 指定数目的匹配 {n,} : 不少于指定数目的匹配 {n,m} : 匹配数目的范围(m不超过255) 可以用[0-9]{4}或者[[:digit:]]{4}来代表4个数字 定位符 ^ : 文本的开始(在[和]集合中表示否定该集合) $ : 文本的结束 [[:&lt;:]] : 词的开始 [[:&gt;:]] : 词的结尾 通过^和$可以使REGEXP的作用类似于LIKE 第十章 创建计算字段 Concat(arg1,arg2,…) 这个函数在select后使用，可以将查询出来的数据以字符串的形式拼接起来 如: select Concat(名字, ‘ (‘, 城市, ‘)’) RTrim() LTrim()去掉左边多余空格 LTrim()去掉左边多余空格 S 关键字用于起别名 可以在select语句后面对列进行算数运算，然后在用AS起个别名，客户机就可以像用其他列一样用这个列 第十一章 使用数据处理函数常用文本处理函数 SOUNDEX() 是一个将任何文本串转换为描述其语音表示的字母数字模式的算法 用于匹配发音类似的值123select cust_name, cust_contactFROM customerswhere SOUNDEX(cust_contact)= SOUNDEX('Y.Lie') 日期处理函数 日期必须为yyyy-mm-dd格式 不过当你想要用日期和表中的日期相比较时，你应当使用Date()函数 Date()函数指示MySQL仅提取日期部分，例:123select cust_id, order_num from orders where Date(order_date) = '2005-09-01'; 当你只想要时间时，可以使用Time() 如果你想检索出2005年9月下的所有订单，你可以用下面两种方法 where Date(order_date) BETWEEN '2005-09-01' and '2005-09-30'; where Year(order_date) = 2005 and Month(order_date) = 9;数值处理函数 第十二章 汇总数据聚集函数 AVG()函数 求平均值 忽略值为null的行 COUNT()函数 COUNT(*) : 返回总的行数，不管是列中是否为空(null) COUNT(column) : 有指定的列名时，指定列的值null的时候，被忽略 聚集不同值 使用DISTINCT关键字，比如说AVG(DISTINCT price)，取平均值时，只考虑不同价格的。 使用DISTINCT关键字，必须使用列名不能用于计算或表达式 第十三章 分组数据 分组例子123select vend_id, count(*)from productsgroup by vend_id; GROUP BY 重要规定 GROUP BY可以包含任意数量的列，使得能对分组进行嵌套，为数据分组提供更细致的控制 GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。就是说，在建立分组时，指定的所有列都一起计算 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式(但不能是聚集函数)。如果在select中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名 除聚集计算语句外，select语句中的每个列都必须在GROUP BY子句中给出 如果愤怒中具有多个null值，则null将作为一个分组返回。如果有多个null，它们将分为一组 GROUP BY子句必须出现在WHERE子句后，ORDER BY子句之前 使用ROLLUP 可以得到每个分组以及每个分组汇总级别(针对每个分组)的值123select vend_id, count(*) as num_prodsFROM productsGROUP BY vend_id with ROLLUP 结果:","link":"/2019/07/22/MySQL必知必会-读书笔记/"},{"title":"Spring学习笔记(3)","text":"动态代理 特点: 字节码随用随创建，随用随加载 作用: 不修改源码的基础下，使方法增强 分类: 基于接口的动态代理 基于子类的动态代理 基于接口的动态代理 涉及的类: Proxy 提供者: JDK 如何创建代理对象 使用Proxy类中的newProxyInstance方法 创建代理对象的要求 被代理对象最少实现一个接口，如果没有则不能使用 newProxyInstance方法的参数: ClassLoader: 类加载器 它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器(就是你要代理谁，就写谁的类加载器)【固定写法】 Class[]: 字节码数组 它是用于让代理对象和被代理对象有相同方法【固定写法】 InvocationHandler: 用于提供增强的代码 它是让我们写如何代理，一般都是写一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的 此接口的实现类是谁用谁写 基于接口动态代理的一个例子当我们的类不实现接口的时候，是不能用动态代理的123456789101112131415161718192021222324252627public static void main(String[] args) { final Producer producer = new Producer(); IProducer proxyProduce = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() { /** * 作用:执行被代理的对象的任何接口方法都会经过该方法 * 方法参数的含义 * @param proxy * @param method 当前执行的方法 * @param args 当前执行的方法所需的参数 * @return 和被代理对象方法有相同的返回值 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 提供增强的代码 Object returnValue = null; // 1.获取方法执行的参数 Float money = (Float) args[0]; // 2.判断当前方法是不是销售 if (\"saleProduct\".equals(method.getName())){ returnValue = method.invoke(producer, money*0.8f); } return returnValue; } }); proxyProduce.saleProduct(10000); } 基于子类的动态代理需要第三方JAR包的支持12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.1_3&lt;/version&gt;&lt;/dependency&gt; 涉及的类: Enhancer 提供者: 第三方类库cglib 如何创建代理对象 使用Enhancer类中的create方法 创建代理对象的要求 被代理类不能是最终类(最终类就不能创建子类了) create方法的参数: Class: 字节码 用于指定被代理对象的字节码 Callback: 用于提供增强的代码 它是让我们写如何代理，一般都是写一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的 此接口的实现类是谁用谁写 我们一般写的都是该接口的子接口实现类: MethodInterceptor 代码实现12345678910111213141516171819202122232425262728public static void main(String[] args) { final Producer producer = new Producer(); Producer proxyProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() { /** * 执行被代理对象的任何方法都会经过该方法 * @param proxy 代理对象的引用 * @param method 当前执行的方法 * @param args 当前执行的方法所需的参数 * 以上三个参数和基于接口的动态代理是一样的 * @param methodProxy 当前执行方法的代理对象 * @return * @throws Throwable */ public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { // 提供增强的代码 Object returnValue = null; // 1.获取方法执行的参数 Float money = (Float) args[0]; // 2.判断当前方法是不是销售 if (\"saleProduct\".equals(method.getName())){ returnValue = method.invoke(producer, money*0.8f); } return returnValue; } }); proxyProducer.saleProduct(10000); } 通过动态代理改善代码即实现了简化开发，又实现了事务控制1234567891011121314151617181920212223242526272829303132333435363738394041/** * 用于创建Service代理对象的工厂 */public class BeanFactory { private AccountService accountService; private TransactionManager txManager; public void setTxManager(TransactionManager txManager) { this.txManager = txManager; } public final void setAccountService(AccountService accountService) { this.accountService = accountService; } public AccountService getAccountService(){ return (AccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object rtValue = null; try { // 1.开启事务 txManager.beginTransaction(); // 2.执行操作 rtValue = method.invoke(accountService, args); // 3.提交事务 txManager.commit(); // 4.返回结果 return rtValue; } catch (Exception e){ // 5.回滚操作 txManager.rollback(); throw new RuntimeException(e); } finally { // 6.释放连接 txManager.release(); } } }); }} AccountServiceImpl123456789101112131415public void transfer(String sourceName, String targetName, Integer money) { System.out.println(\"transfer\"); Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); accountDao.updateAccount(source);// int i = 1/0; accountDao.updateAccount(target); } 测试类123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:bean.xml\")public class AccountServiceTest { @Autowired @Qualifier(\"proxyAccountService\") private AccountService accountService; @Test public void testTransfer() { accountService.transfer(\"aaa\", \"bbb\", 100); }} bean.xml123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置代理的Service--&gt; &lt;bean id=\"proxyAccountService\" factory-bean=\"beanFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; &lt;!--配置BeanFactory--&gt; &lt;bean id=\"beanFactory\" class=\"com.xushui.factory.BeanFactory\"&gt; &lt;property name=\"txManager\" ref=\"transactionManager\"&gt;&lt;/property&gt; &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; ...","link":"/2019/08/04/Spring学习笔记-3/"},{"title":"Spring学习笔记(1)","text":"Spring的概述Spring是什么Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC(Inverse Of Control:反转控制)和AOP(Aspect Oriented Programming:面向切面编程)为内核，提供展现层 SpringMVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库。 程序耦合以及解耦 程序的耦合 耦合: 程序间的依赖关系 包括: 类之间的依赖 方法间的依赖 解耦: 降低程序间的依赖关系 实际开发中: 应该做到编译期不依赖，运行时才依赖 解耦思路: 使用反射来创建对象，而避免用new 通过读取配置文件来获取要创建对象的全限定类名 用工厂模式创建对象(解耦)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 一个创建Bean对象的工厂 * * Bean: 在计算机英语中，有可重用组件的含义。 * JavaBean: 用Java语言编写的可重用组件 * JavaBean &gt; 实体类 * * 他就是创建service和dao对象的。 * * 1. 需要一个配置文件来配置service和dao * 配置的内容: 唯一标志=全限定类名(key=value) * 2. 通过读取配置文件中的配置的内容，反射创建对象 * * 配置文件可以是xml也可以是properties */public class BeanFactory { // 定义一个Properties对象 private static Properties prop; // 定义一个Map，用于存放我们要创建的对象。我们把它称之为容器 private static Map&lt;String, Object&gt; beans; // 使用静态代码块为Properties对象赋值 static { try { prop = new Properties(); // 获取properties文件的流对象【一定要用类加载器来访问，不然程序一旦部署就找不到，放在resources下的配置文件，最后会成为根路径下的文件】 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(\"bean.properties\"); prop.load(in); // 实例化容器 beans = new HashMap&lt;String, Object&gt;(); // 取出配置文件中所有的key Enumeration&lt;Object&gt; keys = prop.keys(); // 遍历枚举 while (keys.hasMoreElements()) { // 取出每个key String key = keys.nextElement().toString(); // 根据key获取value String beanPath = prop.getProperty(key); // 反射创建对象 Object value = Class.forName(beanPath).newInstance(); // 把key和value存入容器中 beans.put(key, value); } } catch (Exception e) { // 没有读取到这个配置文件，直接抛出异常。无法继续进行下去。 throw new ExceptionInInitializerError(\"初始化properties失败\"); } } /** * 用这种方式将方法名和Bean存放在HashMap中，通过key(方法名)来取出对象。这样的对象是单例的 * @param beanName * @return */ public static Object getBean(String beanName) { return beans.get(beanName); } 有了这样的工厂就可以通过AccountService service = (AccountService) BeanFactory.getBean(&quot;accountService&quot;);方式来创建对象，就是将创建对象的控制权交给了工厂，这就是控制反转 通过这种方式降低了程序之间的耦合 IOC的概念和Spring中的IOC控制反转(IOC)把对象创建的权利交给了框架，是框架的重要特征，它包括了依赖注入(DI)和依赖查找(Dependency Lookup)。其主要作用就是削减计算机程序的耦合(程序间的依赖关系) Spring中基于XML的IOC环境搭建 在pom.xml的依赖中加入 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 然后在resources中创建一个bean.xml文件并导入约束 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 把对象的创建交给Spring来管理 12&lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.xushui.dao.Impl.AccountDaoImpl\"&gt;&lt;/bean&gt; 4.测试代码123456789101112131415/** * 获取spring的IOC核心容器，并根据id获取对象 * @param args */ public static void main(String[] args) { // 1.获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); // 2.根据id获取bean对象 AccountService accountService = (AccountService) ac.getBean(\"accountService\"); // 两种方式都可以，一种是强制转换，一种是加上你要转的类的字节码文件 AccountDao accountDao = ac.getBean(\"accountDao\",AccountDao.class); System.out.println(accountService); System.out.println(accountDao); } 一些要注意的地方ApplicationContext的三个常用实现类1. ClassPathXmlApplicationContext: 它可以加载类路径下的配置文件，要求配置文件必须在类路径下(常用) 2. FileSystemXmlApplicationContext: 它可以加载磁盘任意路径下的配置文件(必须有访问权限) 3. AnnotationConfigApplicationContext: 它是用于读取注解创建容器的 核心容器的两个接口引发的问题ApplicationContext(大多数采用这个): 单例对象适用 它在构建核心容器时，创建对象采取的策略是立即加载的方式(一读取完配置文件马上创建配置文件中配置的对象) Spring是个很智能的框架，当你选择作用范围为prototype时，它会自动变为延迟加载策略 BeanFactory: 多例对象适用 它在构建核心容器时，采用的是延迟加载的策略(什么时候根据id获取对象了，什么时候才创建对象) Spring对bean管理的细节创建bean的三种方式 使用默认构造函数创建，若类中没有默认构造方法，则对象无法创建 1&lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt;&lt;/bean&gt; 使用普通工厂中的方法创建对象(使用某个类中的方法创建对象，并存入spring容器) 12&lt;bean id=\"instanceFactory\" class=\"com.xushui.factory.InstanceFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"accountService\" factory-bean=\"instanceFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; 使用工厂中的静态方法创建对象(使用某个类的静态方法创建对象，并存入spring容器) 1&lt;bean id=\"accountService\" class=\"com.xushui.factory.StaticFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; bean对象的作用范围bean作用范围调整 bean标签的scope属性: 作用:用于指定bean的作用范围 取值: 前两个比较常用 singleton: 单例的(默认值) prototype: 多例的 request: 作用于web项目的请求范围 session: 作用于web项目的会话范围 global-session: 作用于集群环境的会话范围(全局会话范围)，当不是集群环境时，他就是session bean对象的生命周期 单例对象 出生: 当容器创建时，对象出生 活着: 只要容器还在，对象一直活着 死亡: 容器销毁，对象死亡 总结: 单例对象的生命周期和容器相同 多例对象 出生: 当我们使用对象时，Spring框架为我们创建 活着: 对象只要是在使用过程中。一直是活着 死亡: 当对象长时间没用，且没有别的对象引用，由Java的垃圾回收机制回收 依赖注入(Dependency Injection) 依赖关系的管理: 都交由Spring框架来维护 当前类需要其他类的对象，由Spring提供，我们只用在配置文件中说明 依赖关系的维护我们就称之为依赖注入 注意: 经常变化的数据，并不适合注入方式 支持注入的数据类型 基本类型和String 其他bean类型(配置文件中或者注解配置过的bean) 复杂类型/集合类型 注入类型 使用构造函数提供 使用set方法提供 使用注解提供 构造函数的注入 使用的标签: constructior-arg 标签出现的位置: bean标签的内部 标签中的属性 type: 用于指定要注入的数据的数据类型，该数据赋值给构造函数中该数据类型的一个或多个 index: 用于给构造函数中指定索引位置的参数赋值 索引从0开始 name: (常用)用于给构造函数中指定名字的参数赋值 value: 用于提供String类型和基本类型的数据 ref: 用于指定其他bean类的数据，值得就是Spring的IOC核心容器中出现过的bean对象 示例123456789101112131415public class AccountServiceImpl implements AccountService { private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday){ this.name = name; this.age = age; this.birthday = birthday; } public void saveAccount() { System.out.println(\"保存了 \" + \"名字: \" + name +\", 年龄: \"+age+\", 生日: \" + birthday); }} bin.xml中 1234567&lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 优势: 在获取bean对象时，注入数据是必须的操作，否则对象无法创建。弊端: 改变了bean的实例化方式，即使我们在创建对象时，用不到这些数据，也必须提供 set方法注入(常用) 使用的标签: property 出现的位置: bean标签的内部 标签属性: name:用于指定注入时所调用set的方法的名称 value和ref与构造函数注入一样 优势: 创建对象是没有明确的限制，可以直接使用默认的构造函数弊端: 如果有某个成员必须有值，set方法无法保证 复杂类型/集合类型注入12345678910111213141516171819202122232425262728293031323334353637&lt;bean id=\"accountService3\" class=\"com.xushui.service.Impl.AccountServiceImpl3\"&gt; &lt;property name=\"myStrs\"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;set&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"keyA\" value=\"aaa\"&gt;&lt;/entry&gt; &lt;entry key=\"keyB\"&gt;&lt;value&gt;bbb&lt;/value&gt;&lt;/entry&gt; &lt;entry key=\"keyC\" value=\"ccc\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;props&gt; &lt;prop key=\"AAA\"&gt;bbb&lt;/prop&gt; &lt;prop key=\"CCC\"&gt;Ddd&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 用于给List结构集合注入标签: list、array、set 用于给Map结构集合注入标签: map、props 结构相同标签可以互换","link":"/2019/08/01/Spring学习笔记-1/"},{"title":"Spring学习笔记(2)","text":"基于注解的IOC配置创建对象作用与xml配置文件中的&lt;bean&gt;标签实现的功能是一样的 @Component: 作用: 用于把当前类对象存入Spring容器中 属性: value: 用于指定bean的id，默认值为当前类名(首字母改为小写) 以下三种作用和属性和@Component是一样的，是Spring框架提供的明确三层使用的注解。 @Controller: 一般用在表现层 @Service: 一般用在业务层 @Repository: 一般用在持久层 当三层都不属于的对象可以选择使用@Component 注入数据作用与在xml配置文件中&lt;bean&gt;标签里写一个&lt;property&gt;是一样的 @Autowired 作用: 按照类型注入，只要容器中有唯一的一个bean对象类型和注入的变量类型匹配，就能成功注入 如果IOC容器中没有任何bean的类型和要注入对象的类型匹配，则报错 如果IOC容器中有多个bean的类型和要注入对象匹配时: 被注入的对象和其中一个bean的名称相同时，可以将名字相同的注入 被注入的对象和所有的bean的名称不同时，会因为不知道选择哪个而报错 出现位置: 可以是变量上，也可以是方法上 细节: 使用注解注入，set方法不是必须的 @Qualifier 作用: 在按照类中注入的基础之上再按照名称注入，它在给成员变量注入时不能单独使用(要和@AutoWired注解一起使用)，但是再给方法参数注入时可以 属性: value: 用于指定注入bean的id 给方法使用的例子当有多个数据源可以使用时，你可以用@Qualifier注解添加你想要的那个，此时@Qualifier可以单独使用12345@Bean(\"runner\") @Scope(\"prototype\") public QueryRunner createQueryRunner(@Qualifier(\"dataSource1\") ComboPooledDataSource dataSource) { return new QueryRunner(dataSource); } @Resource 作用: 直接按照bean的id注入，可以独立使用 属性: name: 用于指定bean的id 以上三种注入方式都只能注入其他bean类型的数据，不能注入String和基本类型，其中集合类型的注入只能通过xml配置的方式实现 @Value 作用: 用于注入基本类型和String类型的数据 属性: value: 用于指定数据的值，它可以使用Spring中SpringEL表达式 作用范围作用与在&lt;bean&gt;标签中使用scope属性实现的功能是一样的 @Scope 作用:用于指定bean的作用范围 属性: value: 指定作用范围的取值 常用取值: singleton(默认): 单例 prototype: 多例 生命周期(了解)作用与&lt;bean&gt;标签中使用init-method和destroy-method的作用是一样的 @PreDestroy 作用: 用于指定销毁方法 @PostConstruct 作用: 用于指定初始化方法 实现注解IOC配置需要的操作告知Spring在创建容器时需要扫描的包，配置所需的标签不是在beans的约束中，而是一个叫context名称空间和约束中 为bean.xml添加约束(在Spring官方文档中搜索xmlns:context) 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 加入&lt;context:component-scan base-package=&quot;com.xushui&quot;&gt;&lt;/context:component-scan&gt;语句，来对指定目录的包进行扫描 引入注入数据12345678@Component(\"accountService\")public class AccountServiceImpl implements AccountService { //还未注入数据 private AccountDao accountDao = null; public void saveAccount() { accountDao.saveAccount(); }} 直接在测试类中调用方法，会有java.lang.NullPointerException(空指针异常)，所以我们还需要注入数据 Spring新注解@Configuration 作用: 指定当前类为配置类 细节: 当配置类作为AnnotationConfigApplicationContext方法的参数时，可以不写 ComponentScan 作用: 用于通过注解指定Spring在创建容器时要扫描的包 属性: value: 他和basePackages的作用是一样的，等同于在xml里配置了&lt;context:component-scan base-package=&quot;com.xushui&quot;&gt;&lt;/context:component-scan&gt; @Bean 作用: 用于把当前方法的返回值作为bean对象存入到Spring的IOC容器中 属性: name: 用于指定bean的id，默认值是当前方法的名称 细节: 当我们使用注解配置方法时，如果方法有参数，Spring框架会去容器中查找有没有可用的bean对象 查找的方式和Autowired注解的作用是一样的 其他注解@Import 作用: 用于导入其他的配置类 属性: value: 用于指定其他配置类的字节码 有Import注解的配置类就为主配置类，而导入的都是子配置类 @PropertySource 作用: 用于指定properties文件的位置 属性: value: 指定文件的名称和路径关键字: classpath，表示类路径下 小案例xml案例bean.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.xushui.dao.Impl.AccountDaoImpl\"&gt; &lt;property name=\"runner\" ref=\"queryRunner\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"queryRunner\" class=\"org.apache.commons.dbutils.QueryRunner\" scope=\"prototype\"&gt; &lt;constructor-arg name=\"ds\" ref=\"dateSource\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"dateSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"******\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在bean.xml中配置好后要通过ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);来加载配置文件 注解形式用了注解后，就不需要set方法，用AutoWired自动配置123456@Repository(\"accountDao\")public class AccountDaoImpl implements AccountDao { @Autowired private QueryRunner runner = null; ... 也可以使用resource注解指定bean对象的id123456@Repository(\"accountDao\")public class AccountDaoImpl implements AccountDao { @Resource(name = \"runner\") private QueryRunner runner = null; ... AccountService中也是一样12345@Service(\"accountService\")public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao = null; ... 最重要的是创建一个配置类123456789101112131415161718192021222324252627/** * 他是一个配置类，作用和bean.xml一样 * Configuration表示当前类就是配置类 */@Configuration@ComponentScan(\"com.xushui\")public class SpringConfiguration { @Bean(\"runner\") public QueryRunner createQueryRunner(ComboPooledDataSource dataSource) { return new QueryRunner(dataSource); } @Bean(\"dataSource\") public ComboPooledDataSource createDataSource() { try { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/spring\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"******\"); return dataSource; } catch (Exception e) { throw new RuntimeException(\"数据库连接初始化失败\"); } }} 当这些都具备了就可以不需要bean.xml了然后通过ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);来加载配置类 小优化此时当这些都完成了，还有一个要注意的地方是runner此时还是个单例的对象，线程不安全，添加注解@Scope(&quot;prototype&quot;)12345@Bean(\"runner\") @Scope(\"prototype\") public QueryRunner createQueryRunner(ComboPooledDataSource dataSource) { return new QueryRunner(dataSource); } 可以添加一个jdbc的配置类，用主配置文件加上@Improt注解的形式导入jdbc的配置类。同时加上@PropertySource将配置文件加载进来123456789101112@Import(JdbcConfig.class)@Configuration@ComponentScan(\"com.xushui\")@PropertySource(\"classpath:jdbc.properties\")public class SpringConfiguration { @Bean(\"runner\") @Scope(\"prototype\") public QueryRunner createQueryRunner(ComboPooledDataSource dataSource) { return new QueryRunner(dataSource); } } 用Spring的el表达式读取配置文件12345678910111213141516171819202122232425262728public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String username; @Value(\"${jdbc.password}\") private String password; @Bean(\"dataSource\") public ComboPooledDataSource createDataSource() { try { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource; } catch (Exception e) { throw new RuntimeException(\"数据库连接初始化失败\"); } }} Spring整合junit的配置 导入Spring整合junit的jar包(坐标) 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 使用junit提供的一个注解，把原有的main方法替换了，替换成Spring提供的@Runwith(SpringJunit4ClassRunner.class) 告知Spring的运行器，Spring和IOC的创建是基于xml还是注解的，并且说明位置 @ContextConfiguration locations: 指定xml文件的位置，加上classpath关键字，表示在类路径下 classes: 指定注解类所在的位置 在测试类中，就可以通过这几个注解，就可以不用自己导入配置类或配置文件，可以直接使用Spring的IOC容器中的对象123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class AccountServiceTest { @Autowired private AccountService accountService; ... 需要注意的是Spring5.x版本，只支持4.12版本以上的JUnit","link":"/2019/08/03/Spring学习笔记-2/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[]}