{"pages":[{"title":"about","text":"Myhere1 关于作者 90后，大四在读 联系方式 微信: xu6980584 博客: https://myhere1.github.io/ 扫码添加作者","link":"/about/index.html"}],"posts":[{"title":"Mybatis延迟加载和缓存","text":"Mybatis中的延迟加载延迟加载的引入引入问题:在一对多中，当我们有一个用户，它有100个账户。 在查询用户的时候要不要把所有的账户都查询出来？ 在查询账户的时候，要不要把关联的用户查出来？&nbsp; 在查询用户时，用户下的账户信息应当是，什么时候用，什么时候查询出来 在查询账户时，账户所属的用户信息应当是随着账户查询时一起查询出来 什么是延迟加载？在真正使用数据时，才发起查询。按需加载(懒加载) 什么是立即加载？不管有没有使用到，只要一调用方法，马上发起查询 在对应的四种表关系中：一对多，多对一，一对一，多对多一对多、多对多 : 一般采取延迟加载 一对一、多对一 : 一般采用立即加载 开启延迟加载在主配置文件SqlMapConfig.xml中1234567&lt;!--配置参数--&gt; &lt;settings&gt; &lt;!--开启Mybatis延迟加载的全局开关--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--每个属性都会按需加载 可以不配 默认值就是false--&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"&gt;&lt;/setting&gt; &lt;/settings&gt; 在AccountMapper.xml中1234567891011&lt;resultMap id=\"accountUserMap\" type=\"account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!--1对1关系映射,配置封装user内容 column设置为从表中的外键--&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"user\" select=\"com.xushui.dao.UserMapper.findById\"&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findAll\" resultMap=\"accountUserMap\" &gt; select * from account a&lt;/select&gt; 在UserMapper.xml中123&lt;select id=\"findById\" parameterType=\"Integer\" resultType=\"User\"&gt; select * from user where id = #{id}&lt;/select&gt; 当只执行，不需要用到用户信息时，使用了延迟加载1234@Test public void testFindAll() { List&lt;Account&gt; accounts = accountMapper.findAll(); } 在日志信息中可以看到1232019-07-31 10:34:20,357 723 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Preparing: select * from account a 2019-07-31 10:34:20,392 758 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Parameters: 2019-07-31 10:34:20,477 843 [ main] DEBUG shui.dao.AccountMapper.findAll - &lt;== Total: 3 若需要用户信息时12345678@Testpublic void testFindAll() { List&lt;Account&gt; accounts = accountMapper.findAll(); for (Account account : accounts) { System.out.println(account); System.out.println(account.getUser()); }} 在日志中可以看到对用户信息发起了查询1234567891011121314152019-07-31 10:44:13,182 635 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Preparing: select * from account a 2019-07-31 10:44:13,229 682 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Parameters: 2019-07-31 10:44:13,285 738 [ main] DEBUG shui.dao.AccountMapper.findAll - &lt;== Total: 32019-07-31 10:44:13,286 739 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Preparing: select * from user where id = ? 2019-07-31 10:44:13,286 739 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Parameters: 41(Integer)2019-07-31 10:44:13,295 748 [ main] DEBUG xushui.dao.UserMapper.findById - &lt;== Total: 1Account{id=1, uid=41, money=1000.0}User{id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;}2019-07-31 10:44:13,295 748 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Preparing: select * from user where id = ? 2019-07-31 10:44:13,295 748 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Parameters: 45(Integer)2019-07-31 10:44:13,297 750 [ main] DEBUG xushui.dao.UserMapper.findById - &lt;== Total: 1Account{id=2, uid=45, money=1000.0}User{id=45, username=&apos;传智播客&apos;, birthday=Sun Mar 04 12:04:06 CST 2018, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;}Account{id=3, uid=41, money=2000.0}User{id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;} Mybatis中的缓存什么是缓存？存在内存中的临时数据，比如说在第一次查询之后，就将其存储在内存，下一次要使用时，就不需要再去数据库查询，减少与数据库交互的次数，从而提高执行效率。 为什么使用缓存？减少和数据库交互次数，提高执行效率。 什么样的数据能使用缓存，什么样的数据不能使用？- 适用于缓存 - 使用频率高的数据 - 不经常改变的数据 - 数据的正确与否对最终效果影响不大的数据 - 不适用缓存的 - 经常改变的数据 - 数据的正确与否对最终结果影响很大的数据 - 例:商品的库存，银行的汇率，股市的牌价 Mybatis中的一级缓存和二级缓存一级缓存- 它指的是Mybatis中SqlSession对象的缓存 - 当我们执行查询之后，查询结果会同时存入到SqlSession为我们提供的一片区域中 - 结构是一种Map，当我们再次查询同样的数据，Mybatis会先从SqlSession中查询是否有，有的话就可以直接使用 - 当Sqlsession对象消失时，mybatis中的一级缓存就消失了 示范:12345678@Test public void testFirstCache(){ User user1 = userMapper.findById(41); System.out.println(user1); User user2 = userMapper.findById(41); System.out.println(user2); System.out.println(user1 == user2); } 日志中，可以看出只查询了一次，第二次是从缓存中取出。不过必须要确保SqlSession对象是同一个对象，没有消失，如果消失了，或者使用了clearCache()方法，缓存会被清空，就要重新查询。 1234562019-07-31 11:44:29,587 607 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Preparing: select * from user where id = ? 2019-07-31 11:44:29,618 638 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Parameters: 41(Integer)2019-07-31 11:44:29,647 667 [ main] DEBUG xushui.dao.UserMapper.findById - &lt;== Total: 1com.xushui.domain.User@e720b71com.xushui.domain.User@e720b71true 一级缓存的分析一级缓存是SqlSession范围的缓存，当调用SqlSession的修改，添加，删除，commit()，close()方法时，会清空一级缓存 二级缓存它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象所生产的SqlSession所共享的缓存 二级缓存的使用步骤 让Mybatis框架支持二级缓存(在SqlMapConfig.xml中配置) 1234&lt;settings&gt; &lt;!--全局开启缓存，默认为true--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 让当前的映射文件支持二级缓存(在UserMapper.xml中配置) 12&lt;!--开启UserMapper支持二级缓存--&gt; &lt;cache/&gt; 让当前的操作支持二级缓存(在当前操作的标签上配置useCache为true) 123&lt;select id=\"findById\" parameterType=\"Integer\" resultType=\"User\" useCache=\"true\"&gt; select * from user where id = #{id}&lt;/select&gt;","link":"/2019/07/30/Mybatis延迟加载和缓存/"},{"title":"mysql必知必会 读书笔记","text":"第一章 了解SQL数据库概念​ 数据库是一种以某种有组织的方式存储的数据集合 主键的条件 任意两行都不惧有相同的主键值 每个行都必须具有一个主键值(不允许存在null) 好习惯 不更新主键列中的值 不重用主键列中的值 不再主键列中使用可能会更改的值 第三章 使用MySQL 显示表列 show columns from 表名;(describe 表名) 自增 auto_increment 显示建表语句 show create table 表名; 显示建数据库语句 show create database 数据库名; 第四章 索引数据 去处重复 select DISTINCT 列名 from 表名 DISTINCT作用于后面的所有列，使用了这个关键字除非后面的列都相等，否则会全部都索引出来。 限制结果 select 列名 from 表名 limit 5; 表示返回前5行 为了得出下一个五行 select 列名 from 表名 limit 5,5; 从第五行开始往后索引5条记录 第五章 排序索引数据 关系数据库设计理论认为，如果不能明确规定排序顺序，则不应该假定索引出的数据的顺序有意义。 数据排序 select 列名 from 表名 order by 列名; 在where关键字之后使用 可以使用非索引的列作为排序的依据 也可以用多个列作为排序的依据，按代码的顺序，来决定主次，如果主列中的值都是唯一的，则不会用次列的值排序 数据逆序排列 select 列名 from 表名 order by 列名 DESC; 在需要逆序排列的列名后加上DESC关键字 正序是ASC，是默认值 第六章 过滤数据第七章 数据过滤 在where之后and的优先级比or要高，所以在多条件组合时要注意，尽量用括号来解决。 IN ()用来指定条件范围，范围中的每个条件都可以进行匹配 IN的优点 语法更清除直观 计算次序更容易管理 IN操作符比OR操作符清单执行更快 IN的可以包含其他select语句，能够动态的建立Where子句 NOT操作符否定之后所跟的任何条件 MySQL支持对IN、BETWEEN、EXISTS子句取反 第八章 用通配符进行过滤 % 表示任何字符出现任意次数(甚至是0次) 但是%通配符不能匹配null _ 表示任何字符出现一次 关于通配符的技巧 通配符会让搜索时间变长 不要过度使用通配符，如果其他操作可以达到相同的目的，就应该使用其他操作符 确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据 第九章 用正则表达式进行搜索 MySQL正则表达式 REGEXP 与 like用法一致，后面跟的是正则表达式 MySQL中的正则表达式匹配不区分大小写，为区分大小写，可以使用BINARY关键字，如:where 列名 REGEXP BINARY ‘字符串’; 比起LIKE匹配整串而REGEXP匹配子串 正则表达式 . 表示任意一个字符 | 表示或 [和] [123]表示1或2或3，可以理解为[1|2|3] 可以用^来取反 [^123]就匹配除这些字符以外的字符 [0-9] 匹配数字0-9 [a-z] 匹配所有的字母 当需要匹配特殊符号时 采用加\\(两个反斜杠)的方式来区分\\.表示. 下面的标示用来标示前面一个字符 - : 表示0个或多个匹配 + : 表示1个或多个匹配 ? : 表示0个或1个匹配 {n} : 指定数目的匹配 {n,} : 不少于指定数目的匹配 {n,m} : 匹配数目的范围(m不超过255) 可以用[0-9]{4}或者[[:digit:]]{4}来代表4个数字 定位符 ^ : 文本的开始(在[和]集合中表示否定该集合) $ : 文本的结束 [[:&lt;:]] : 词的开始 [[:&gt;:]] : 词的结尾 通过^和$可以使REGEXP的作用类似于LIKE 第十章 创建计算字段 Concat(arg1,arg2,…) 这个函数在select后使用，可以将查询出来的数据以字符串的形式拼接起来 如: select Concat(名字, ‘ (‘, 城市, ‘)’) RTrim() LTrim()去掉左边多余空格 LTrim()去掉左边多余空格 S 关键字用于起别名 可以在select语句后面对列进行算数运算，然后在用AS起个别名，客户机就可以像用其他列一样用这个列 第十一章 使用数据处理函数常用文本处理函数 SOUNDEX() 是一个将任何文本串转换为描述其语音表示的字母数字模式的算法 用于匹配发音类似的值123select cust_name, cust_contactFROM customerswhere SOUNDEX(cust_contact)= SOUNDEX('Y.Lie') 日期处理函数 日期必须为yyyy-mm-dd格式 不过当你想要用日期和表中的日期相比较时，你应当使用Date()函数 Date()函数指示MySQL仅提取日期部分，例:123select cust_id, order_num from orders where Date(order_date) = '2005-09-01'; 当你只想要时间时，可以使用Time() 如果你想检索出2005年9月下的所有订单，你可以用下面两种方法 where Date(order_date) BETWEEN '2005-09-01' and '2005-09-30'; where Year(order_date) = 2005 and Month(order_date) = 9;数值处理函数 第十二章 汇总数据聚集函数 AVG()函数 求平均值 忽略值为null的行 COUNT()函数 COUNT(*) : 返回总的行数，不管是列中是否为空(null) COUNT(column) : 有指定的列名时，指定列的值null的时候，被忽略 聚集不同值 使用DISTINCT关键字，比如说AVG(DISTINCT price)，取平均值时，只考虑不同价格的。 使用DISTINCT关键字，必须使用列名不能用于计算或表达式 第十三章 分组数据 分组例子123select vend_id, count(*)from productsgroup by vend_id; GROUP BY 重要规定 GROUP BY可以包含任意数量的列，使得能对分组进行嵌套，为数据分组提供更细致的控制 GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。就是说，在建立分组时，指定的所有列都一起计算 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式(但不能是聚集函数)。如果在select中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名 除聚集计算语句外，select语句中的每个列都必须在GROUP BY子句中给出 如果愤怒中具有多个null值，则null将作为一个分组返回。如果有多个null，它们将分为一组 GROUP BY子句必须出现在WHERE子句后，ORDER BY子句之前 使用ROLLUP 可以得到每个分组以及每个分组汇总级别(针对每个分组)的值123select vend_id, count(*) as num_prodsFROM productsGROUP BY vend_id with ROLLUP 结果:","link":"/2019/07/22/mysql必知必会-读书笔记/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"}],"categories":[]}