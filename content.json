{"pages":[{"title":"about","text":"Myhere1 关于作者 90后，大四在读 联系方式 微信: xu6980584 博客: https://myhere1.github.io/ 扫码添加作者","link":"/about/index.html"}],"posts":[{"title":"Maven学习笔记(基础)","text":"什么是Maven什么是MavenMaven 是一个项目管理工具，它包含了一个项目对象模型 (POM:Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑 两个主要功能Maven的依赖管理当我们涉及到多模块的项目(包含成百个模块或者子项目)，管理依赖就变成一项困难的任务。Maven展示出了它对处理这种情形的高度控制 项目的一键构建 整个构建过程，使用 maven 一个命令可以轻松完成整个工作 构建: 指的是项目从清理、编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理 Maven的使用Maven 仓库Maven仓库的分类 本地仓库 :用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包，优先从本地仓库查找 远程仓库:如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内 中央仓库 :在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件 Maven本地仓库的配置在 MAVE_HOME/conf/settings.xml 文件中配置本地仓库位置(maven 的安装目录下)打开settings.xml，配置如下: 全局 setting 与用户 setting maven 仓库地址、私服等配置信息需要在 setting.xml 文件中配置，分为全局配置和用户配置 在 maven 安装目录下的有 conf/setting.xml 文件，此 setting.xml 文件用于 maven 的所有 project 项目，它作为 maven 的全局配置 如需要个性配置则需要在用户配置中设置，用户配置的 setting.xml 文件默认的位置在:${user.dir} /.m2/settings.xml目录中,${user.dir}指用户目录 maven 会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件 Maven 常用命令 clean: clean 是 maven 工程的清理命令，执行 clean 会删除 target 目录及内容 compile: 是 maven 工程的编译命令，作用是将 src/main/java 下的文件编译为 class 文件输出到 target 目录下 test: test 是 maven 工程的测试命令 mvn test，会执行 src/test/java 下的单元测试类 package: package 是 maven 工程的打包命令，对于 java 工程执行 package 打成 jar 包，对于 web 工程打成 war 包 install: install 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库当下面的指令执行时，前面的操作会自动执行 maven的概念模型Maven 是一个项目管理工具，它包含了一个项目对象模型 (POM:Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑 项目对象模型 (Project Object Model) 一个 maven 工程都有一个 pom.xml 文件，通过 pom.xml 文件定义项目的坐标、项目依赖、项目信息、 插件目标等 依赖管理系统 (Dependency Management System) 通过maven的依赖管理对项目所依赖的jar 包进行统一管理 一个项目生命周期 (Project Lifecycle) 使用 maven 完成项目的构建，项目构建包括:清理、编译、测试、部署等过程，maven 将这些过程规范为一个生命周期 一组标准集合 maven 将整个项目管理过程定义一组标准，比如:通过 maven 构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等 插件(plugin)目标(goal) maven 管理项目生命周期过程都是基于插件完成的 Maven基本知识坐标定义123456789101112&lt;!-- 项目名称，定义为组织名+项目名，类似包名 --&gt; &lt;groupId&gt;com.xushui&lt;/groupId&gt;&lt;!-- 模块名称 --&gt; &lt;artifactId&gt;maven_demo&lt;/artifactId&gt;&lt;!-- 当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本 --&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging &gt; 打包类型: jar:执行 package 会打成 jar 包 war:执行 package 会打成 war 包 pom :用于 maven 工程的继承，通常父工程设置为 pom&lt;/packaging&gt; 依赖范围 A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包括: compile: 编译范围，指 A 在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在 编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包 provided: provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用，provided依赖在编译和测试时需要，在运行时不需要，比如:servlet api 被 tomcat 容器提供 runtime: runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如:jdbc 的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包 test: test 范围依赖在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用， 比如:junit。由于运行时不需要所以 test 范围依赖不会被打包 system: system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR 文件的路径，需要指定 systemPath 磁盘路径，system 依赖不推荐使用 默认引入的 jar 包 ——- compile【默认范围 可以不写】(编译、测试、运行都有效) servlet-api、jsp-api ——- provided (编译、测试 有效，运行时无效防止和 tomcat 下 jar 冲突) jdbc 驱动 jar 包 —- runtime (测试、运行 有效 ) junit —– test (测试有效) 依赖范围由强到弱的顺序是: compile &gt; provided &gt; runtime &gt; test 设置 jdk 编译版本如果需要jdk编译版本为1.812345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; pom基本配置pom.xml 是 Maven 项目的核心配置文件，位于每个工程的根目录，基本配置如下:&lt;project &gt;: 文件的根节点&lt;modelversion &gt;: pom.xml 使用的对象模型版本&lt;groupId &gt;: 项目名称，一般写项目的域名&lt;artifactId &gt;: 模块名称，子项目名或模块名称&lt;version &gt;: 产品的版本号&lt;packaging &gt;: 打包类型，一般有 jar、war、pom 等&lt;name &gt;: 项目的显示名，常用于 Maven 生成的文档&lt;description &gt;: 项目描述，常用于 Maven 生成的文档&lt;dependencies &gt;: 项目依赖构件配置，配置项目依赖构件的坐标&lt;build&gt;: 项目构建配置，配置编译、运行插件等","link":"/2019/08/10/Maven学习笔记/"},{"title":"Mybatis基于注解开发","text":"使用Mybatis注解实现基本的CRUD环境搭建SqlMapConfig.xml的配置123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--引入外部配置文件--&gt; &lt;properties resource=\"jdbcConfig.properties\"&gt; &lt;/properties&gt; &lt;!--配置别名--&gt; &lt;typeAliases&gt; &lt;!--配置的是实体类所在位置--&gt; &lt;package name=\"com.xushui.domain\"&gt;&lt;/package&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;environment id=\"mysql\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"${jdbc.driver}\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"&gt;&lt;/property&gt; &lt;property name=\"password \" value=\"${jdbc.password}\"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定带有注解的dao接口所在位置--&gt; &lt;mappers&gt; &lt;!--配置的是dao所在位置--&gt; &lt;package name=\"com.xushui.dao\"&gt;&lt;/package&gt; &lt;/mappers&gt;&lt;/configuration&gt; 在接口方法的上方直接写上注解，一共有四种注解@Select、@Insert、@Update、Delete 12345678public interface UserMapper { /** * 查询所有用户 * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll();} 测试代码:12345678910111213141516171819public static void main(String[] args) throws Exception{ // 1.获取字节输入流 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 2.根据字节输入流构建SqlSessionFactory SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); // 3.根据SqlSessionFactory生产一个SqlSession SqlSession sqlSession = factory.openSession(); // 4.根据SqlSession获取Dao的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 5.执行dao的方法 List&lt;User&gt; users = userMapper.findAll(); for (User user : users) { System.out.println(user); } // 6.释放资源 sqlSession.close(); in.close(); } 需要注意的事项如果采用了注解开发的形式就不能再在resources中对应目录下写xml，否则就会报错 Mybatis注解开发单表CRUD常用操作示范代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public interface UserMapper { /** * 查询所有用户 * @return */ @Select(\"select * from user\") List&lt;User&gt; findAll(); /** * 保存用户 * @param user */ @Insert(\"insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address})\") void saveUser(User user); /** * 修改user * @param user */ @Update(\"update user set username=#{username},sex=#{sex},address=#{address},birthday=#{birthday} where id=#{id}\") void updateUser(User user); /** * 根据id删除user * @param id */ @Delete(\"delete from user where id = #{id}\") void deleteUser(Integer id); /** * 通过id查找用户 * @param id * @return */ @Select(\"select * from user where id = #{id}\") User findUserById(Integer id); /** * 根据用户名称模糊查询 * @param name * @return */ @Select(\"select * from user where username like #{name}\") List&lt;User&gt; findUserByName(String name); /** * 查询用户总量 * @return */ @Select(\"select count(*) from user\") Integer findTotal();} 多表查询(一对一)用注解的方式解决数据库列名和对象的成员变量名不一致的问题在Mapper中添加注解12345678910111213141516171819202122/** * 查询所有用户 * @return */@Select(\"select * from user\")@Results(id = \"userMap\", value = { @Result(id = true, property = \"userId\", column = \"id\"), @Result(property = \"userName\", column = \"username\"), @Result(property = \"userBirthday\", column = \"birthday\"), @Result(property = \"userSex\", column = \"sex\"), @Result(property = \"userAddress\", column = \"address\")})List&lt;User&gt; findAll();/** * 通过id查找用户 * @param id * @return */@Select(\"select * from user where id = #{id}\")@ResultMap(value = {\"userMap\"})User findUserById(Integer id); 可以通过在定义Map时给id赋值，这样子在下面就可以直接用注解@ResultMap(value = {&quot;userMap&quot;})来复用，这个注解中可以添加多个map，当只有一个时，可以简写成@ResultMap(&quot;userMap&quot;) 第一步若是一对一的关系在一个对象中添加另一个对象作为成员变量例如:123456789public class Account implements Serializable { private Integer id; private Integer uid; private Integer money; // 一对一的映射 private User user; ......} 第二步在方法上添加注解123456789101112131415public interface AccountMapper { /** * 查询所有账户，并且获得每个账户所属的用户信息 * @return */ @Select(\"select * from account\") @Results(id = \"accountMap\", value = { @Result(id = true, property = \"id\", column = \"id\"), @Result(property = \"uid\", column = \"uid\"), @Result(property = \"money\", column = \"money\"), // property 表示要封装成什么 | column 表示用什么字段去查 | select 表示指向什么方法 | fetchType表示要选择什么方式加载(lazy延迟加载、eager立即加载) @Result(property = \"user\", column = \"uid\", one = @One(select = \"com.xushui.dao.UserMapper.findUserById\",fetchType = FetchType.EAGER)) }) List&lt;Account&gt; findAll();} 其中最后的@Result()注解中 property: 表示要封装成什么类型的数据 column: 表示要用什么字段去将你要封装的数据查询出来 one: 表示了一对一的注解 select: 表示了你要使用查询方法的全限定类名加方法名 fetchType: 取值有LAZY(延迟加载), EAGER(立即加载), DEFAULT(默认) 多表查询(一对多)第一步若是一对多关系则在一个对象中添加另一个对象的集合1234567891011public class User implements Serializable { private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; // 一对多关系映射 List&lt;Account&gt; accounts; ......} 第二步为AccountMapper添加一个方法1234567/** * 根据用户id查询账户信息 * @param uid * @return */@Select(\"select * from account where uid = #{uid}\")List&lt;Account&gt; findByUid(Integer uid); 第三步给UserMapper添加注解1234567891011121314/** * 查询所有用户，并获取每个用户的所有账户信息 * @return */@Select(\"select * from user\")@Results(id = \"userMap\", value = { @Result(id = true, property = \"userId\", column = \"id\"), @Result(property = \"userName\", column = \"username\"), @Result(property = \"userBirthday\", column = \"birthday\"), @Result(property = \"userSex\", column = \"sex\"), @Result(property = \"userAddress\", column = \"address\"), @Result(property = \"accounts\", column = \"id\", many = @Many(select = \"com.xushui.dao.AccountMapper.findByUid\", fetchType = FetchType.LAZY))})List&lt;User&gt; findAll(); 关于缓存的配置一级缓存在注解配置中是默认可以使用的二级缓存则需要在Mapper上方添加@CacheNamespace(blocking = true)，就可以使用了","link":"/2019/07/31/Mybatis基于注解开发/"},{"title":"MySQL必知必会 读书笔记","text":"第一章 了解SQL数据库概念​ 数据库是一种以某种有组织的方式存储的数据集合 主键的条件 任意两行都不惧有相同的主键值 每个行都必须具有一个主键值(不允许存在null) 好习惯 不更新主键列中的值 不重用主键列中的值 不再主键列中使用可能会更改的值 第三章 使用MySQL 显示表列 show columns from 表名;(describe 表名) 自增 auto_increment 显示建表语句 show create table 表名; 显示建数据库语句 show create database 数据库名; 第四章 索引数据 去处重复 select DISTINCT 列名 from 表名 DISTINCT作用于后面的所有列，使用了这个关键字除非后面的列都相等，否则会全部都索引出来。 限制结果 select 列名 from 表名 limit 5; 表示返回前5行 为了得出下一个五行 select 列名 from 表名 limit 5,5; 从第五行开始往后索引5条记录 第五章 排序索引数据 关系数据库设计理论认为，如果不能明确规定排序顺序，则不应该假定索引出的数据的顺序有意义。 数据排序 select 列名 from 表名 order by 列名; 在where关键字之后使用 可以使用非索引的列作为排序的依据 也可以用多个列作为排序的依据，按代码的顺序，来决定主次，如果主列中的值都是唯一的，则不会用次列的值排序 数据逆序排列 select 列名 from 表名 order by 列名 DESC; 在需要逆序排列的列名后加上DESC关键字 正序是ASC，是默认值 第六章 过滤数据第七章 数据过滤 在where之后and的优先级比or要高，所以在多条件组合时要注意，尽量用括号来解决。 IN ()用来指定条件范围，范围中的每个条件都可以进行匹配 IN的优点 语法更清除直观 计算次序更容易管理 IN操作符比OR操作符清单执行更快 IN的可以包含其他select语句，能够动态的建立Where子句 NOT操作符否定之后所跟的任何条件 MySQL支持对IN、BETWEEN、EXISTS子句取反 第八章 用通配符进行过滤 % 表示任何字符出现任意次数(甚至是0次) 但是%通配符不能匹配null _ 表示任何字符出现一次 关于通配符的技巧 通配符会让搜索时间变长 不要过度使用通配符，如果其他操作可以达到相同的目的，就应该使用其他操作符 确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据 第九章 用正则表达式进行搜索 MySQL正则表达式 REGEXP 与 like用法一致，后面跟的是正则表达式 MySQL中的正则表达式匹配不区分大小写，为区分大小写，可以使用BINARY关键字，如:where 列名 REGEXP BINARY ‘字符串’; 比起LIKE匹配整串而REGEXP匹配子串 正则表达式 . 表示任意一个字符 | 表示或 [和] [123]表示1或2或3，可以理解为[1|2|3] 可以用^来取反 [^123]就匹配除这些字符以外的字符 [0-9] 匹配数字0-9 [a-z] 匹配所有的字母 当需要匹配特殊符号时 采用加\\(两个反斜杠)的方式来区分\\.表示. 下面的标示用来标示前面一个字符 - : 表示0个或多个匹配 + : 表示1个或多个匹配 ? : 表示0个或1个匹配 {n} : 指定数目的匹配 {n,} : 不少于指定数目的匹配 {n,m} : 匹配数目的范围(m不超过255) 可以用[0-9]{4}或者[[:digit:]]{4}来代表4个数字 定位符 ^ : 文本的开始(在[和]集合中表示否定该集合) $ : 文本的结束 [[:&lt;:]] : 词的开始 [[:&gt;:]] : 词的结尾 通过^和$可以使REGEXP的作用类似于LIKE 第十章 创建计算字段 Concat(arg1,arg2,…) 这个函数在select后使用，可以将查询出来的数据以字符串的形式拼接起来 如: select Concat(名字, ‘ (‘, 城市, ‘)’) RTrim() LTrim()去掉左边多余空格 LTrim()去掉左边多余空格 S 关键字用于起别名 可以在select语句后面对列进行算数运算，然后在用AS起个别名，客户机就可以像用其他列一样用这个列 第十一章 使用数据处理函数常用文本处理函数 SOUNDEX() 是一个将任何文本串转换为描述其语音表示的字母数字模式的算法 用于匹配发音类似的值123select cust_name, cust_contactFROM customerswhere SOUNDEX(cust_contact)= SOUNDEX('Y.Lie') 日期处理函数 日期必须为yyyy-mm-dd格式 不过当你想要用日期和表中的日期相比较时，你应当使用Date()函数 Date()函数指示MySQL仅提取日期部分，例:123select cust_id, order_num from orders where Date(order_date) = '2005-09-01'; 当你只想要时间时，可以使用Time() 如果你想检索出2005年9月下的所有订单，你可以用下面两种方法 where Date(order_date) BETWEEN '2005-09-01' and '2005-09-30'; where Year(order_date) = 2005 and Month(order_date) = 9;数值处理函数 第十二章 汇总数据聚集函数 AVG()函数 求平均值 忽略值为null的行 COUNT()函数 COUNT(*) : 返回总的行数，不管是列中是否为空(null) COUNT(column) : 有指定的列名时，指定列的值null的时候，被忽略 聚集不同值 使用DISTINCT关键字，比如说AVG(DISTINCT price)，取平均值时，只考虑不同价格的。 使用DISTINCT关键字，必须使用列名不能用于计算或表达式 第十三章 分组数据 分组例子123select vend_id, count(*)from productsgroup by vend_id; GROUP BY 重要规定 GROUP BY可以包含任意数量的列，使得能对分组进行嵌套，为数据分组提供更细致的控制 GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。就是说，在建立分组时，指定的所有列都一起计算 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式(但不能是聚集函数)。如果在select中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名 除聚集计算语句外，select语句中的每个列都必须在GROUP BY子句中给出 如果愤怒中具有多个null值，则null将作为一个分组返回。如果有多个null，它们将分为一组 GROUP BY子句必须出现在WHERE子句后，ORDER BY子句之前 使用ROLLUP 可以得到每个分组以及每个分组汇总级别(针对每个分组)的值123select vend_id, count(*) as num_prodsFROM productsGROUP BY vend_id with ROLLUP 结果:","link":"/2019/07/22/MySQL必知必会-读书笔记/"},{"title":"Mybatis延迟加载和缓存","text":"Mybatis中的延迟加载延迟加载的引入引入问题:在一对多中，当我们有一个用户，它有100个账户。 在查询用户的时候要不要把所有的账户都查询出来？ 在查询账户的时候，要不要把关联的用户查出来？&nbsp; 在查询用户时，用户下的账户信息应当是，什么时候用，什么时候查询出来 在查询账户时，账户所属的用户信息应当是随着账户查询时一起查询出来 什么是延迟加载？在真正使用数据时，才发起查询。按需加载(懒加载) 什么是立即加载？不管有没有使用到，只要一调用方法，马上发起查询 在对应的四种表关系中：一对多，多对一，一对一，多对多一对多、多对多 : 一般采取延迟加载 一对一、多对一 : 一般采用立即加载 开启延迟加载在主配置文件SqlMapConfig.xml中1234567&lt;!--配置参数--&gt; &lt;settings&gt; &lt;!--开启Mybatis延迟加载的全局开关--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--每个属性都会按需加载 可以不配 默认值就是false--&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"&gt;&lt;/setting&gt; &lt;/settings&gt; 在AccountMapper.xml中1234567891011&lt;resultMap id=\"accountUserMap\" type=\"account\"&gt; &lt;id property=\"id\" column=\"id\"&gt;&lt;/id&gt; &lt;result property=\"uid\" column=\"uid\"&gt;&lt;/result&gt; &lt;result property=\"money\" column=\"money\"&gt;&lt;/result&gt; &lt;!--1对1关系映射,配置封装user内容 column设置为从表中的外键--&gt; &lt;association property=\"user\" column=\"uid\" javaType=\"user\" select=\"com.xushui.dao.UserMapper.findById\"&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findAll\" resultMap=\"accountUserMap\" &gt; select * from account a&lt;/select&gt; 在UserMapper.xml中123&lt;select id=\"findById\" parameterType=\"Integer\" resultType=\"User\"&gt; select * from user where id = #{id}&lt;/select&gt; 当只执行，不需要用到用户信息时，使用了延迟加载1234@Test public void testFindAll() { List&lt;Account&gt; accounts = accountMapper.findAll(); } 在日志信息中可以看到1232019-07-31 10:34:20,357 723 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Preparing: select * from account a 2019-07-31 10:34:20,392 758 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Parameters: 2019-07-31 10:34:20,477 843 [ main] DEBUG shui.dao.AccountMapper.findAll - &lt;== Total: 3 若需要用户信息时12345678@Testpublic void testFindAll() { List&lt;Account&gt; accounts = accountMapper.findAll(); for (Account account : accounts) { System.out.println(account); System.out.println(account.getUser()); }} 在日志中可以看到对用户信息发起了查询1234567891011121314152019-07-31 10:44:13,182 635 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Preparing: select * from account a 2019-07-31 10:44:13,229 682 [ main] DEBUG shui.dao.AccountMapper.findAll - ==&gt; Parameters: 2019-07-31 10:44:13,285 738 [ main] DEBUG shui.dao.AccountMapper.findAll - &lt;== Total: 32019-07-31 10:44:13,286 739 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Preparing: select * from user where id = ? 2019-07-31 10:44:13,286 739 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Parameters: 41(Integer)2019-07-31 10:44:13,295 748 [ main] DEBUG xushui.dao.UserMapper.findById - &lt;== Total: 1Account{id=1, uid=41, money=1000.0}User{id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;}2019-07-31 10:44:13,295 748 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Preparing: select * from user where id = ? 2019-07-31 10:44:13,295 748 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Parameters: 45(Integer)2019-07-31 10:44:13,297 750 [ main] DEBUG xushui.dao.UserMapper.findById - &lt;== Total: 1Account{id=2, uid=45, money=1000.0}User{id=45, username=&apos;传智播客&apos;, birthday=Sun Mar 04 12:04:06 CST 2018, sex=&apos;男&apos;, address=&apos;北京金燕龙&apos;}Account{id=3, uid=41, money=2000.0}User{id=41, username=&apos;老王&apos;, birthday=Tue Feb 27 17:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;} Mybatis中的缓存什么是缓存？存在内存中的临时数据，比如说在第一次查询之后，就将其存储在内存，下一次要使用时，就不需要再去数据库查询，减少与数据库交互的次数，从而提高执行效率。 为什么使用缓存？减少和数据库交互次数，提高执行效率。 什么样的数据能使用缓存，什么样的数据不能使用？- 适用于缓存 - 使用频率高的数据 - 不经常改变的数据 - 数据的正确与否对最终效果影响不大的数据 - 不适用缓存的 - 经常改变的数据 - 数据的正确与否对最终结果影响很大的数据 - 例:商品的库存，银行的汇率，股市的牌价 Mybatis中的一级缓存和二级缓存一级缓存- 它指的是Mybatis中SqlSession对象的缓存 - 当我们执行查询之后，查询结果会同时存入到SqlSession为我们提供的一片区域中 - 结构是一种Map，当我们再次查询同样的数据，Mybatis会先从SqlSession中查询是否有，有的话就可以直接使用 - 当Sqlsession对象消失时，mybatis中的一级缓存就消失了 示范:12345678@Test public void testFirstCache(){ User user1 = userMapper.findById(41); System.out.println(user1); User user2 = userMapper.findById(41); System.out.println(user2); System.out.println(user1 == user2); } 日志中，可以看出只查询了一次，第二次是从缓存中取出。不过必须要确保SqlSession对象是同一个对象，没有消失，如果消失了，或者使用了clearCache()方法，缓存会被清空，就要重新查询。 1234562019-07-31 11:44:29,587 607 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Preparing: select * from user where id = ? 2019-07-31 11:44:29,618 638 [ main] DEBUG xushui.dao.UserMapper.findById - ==&gt; Parameters: 41(Integer)2019-07-31 11:44:29,647 667 [ main] DEBUG xushui.dao.UserMapper.findById - &lt;== Total: 1com.xushui.domain.User@e720b71com.xushui.domain.User@e720b71true 一级缓存的分析一级缓存是SqlSession范围的缓存，当调用SqlSession的修改，添加，删除，commit()，close()方法时，会清空一级缓存 二级缓存它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象所生产的SqlSession所共享的缓存 二级缓存的使用步骤 让Mybatis框架支持二级缓存(在SqlMapConfig.xml中配置) 1234&lt;settings&gt; &lt;!--全局开启缓存，默认为true--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 让当前的映射文件支持二级缓存(在UserMapper.xml中配置) 12&lt;!--开启UserMapper支持二级缓存--&gt; &lt;cache/&gt; 让当前的操作支持二级缓存(在当前操作的标签上配置useCache为true) 123&lt;select id=\"findById\" parameterType=\"Integer\" resultType=\"User\" useCache=\"true\"&gt; select * from user where id = #{id}&lt;/select&gt;","link":"/2019/07/30/Mybatis延迟加载和缓存/"},{"title":"SpringMVC学习笔记(3)","text":"SSM案例 导入坐标123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;${slf4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建目录结构 创建spring的配置创建applicationContext.xml，并导入约束12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--开启注解的扫描，希望处理servlet和dao，controller不需要spring框架处理--&gt; &lt;context:component-scan base-package=\"com.xushui\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 测试业务层Spring框架1234567891011@Service(\"accountService\")public class AccountServiceImpl implements com.xushui.service.AccountService { @Override public void findAll() { System.out.println(\"查询所有账户\"); } @Override public void saveAccount(Account account) { System.out.println(\"保存账户\"); }} Spring测试类123456789public class TestSpring { @Test public void testAccountService(){ ApplicationContext ac = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\"); AccountService accountService = ac.getBean(\"accountService\",AccountService.class); accountService.findAll(); }} 确认Spring框架正常后，进行下一步 SpringMVC框架搭建引入约束1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开启注解扫描，只扫描Controller注解--&gt; &lt;context:component-scan base-package=\"com.xushui\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"&gt;&lt;/context:include-filter&gt; &lt;/context:component-scan&gt; &lt;!--配置视图解析器对象--&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--过滤静态资源--&gt; &lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping=\"/images/**\" location=\"/images/\"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping=\"/css/**\" location=\"/css/\"&gt;&lt;/mvc:resources&gt; &lt;!--开启SpringMVC注解的支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 编写Controller，并测试SpringMVC环境123456789@Controller@RequestMapping(\"/account\")public class AccountController { @RequestMapping(\"testSpringmvc\") public String testSpringmvc(){ System.out.println(\"testSpringmvc执行了...\"); return \"success\"; }} Spring整合SpringMVC目的: 在Controller中能调用service对象的方法 过程: 服务器启动时会创建一个ServletContext域对象，服务器关闭时销毁 有一个监听器，监听ServletContext域对象的创建和销毁，它可以在服务器启动时执行一次 所以我们可以用这个监听器去加载Spring的配置文件 在web.xml配置一个监听器，就可以把Spring的配置文件引入123456789&lt;!--配置Spring的监听器，默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--设置配置文件的路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 然后就可以在Controller中用注解给service对象注入 Mybatis框架搭建 编写配置文件SqlMapConfig.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;environment id=\"mysql\"&gt; &lt;transactionManager type=\"jdbc\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"******\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射配置文件--&gt; &lt;mappers&gt; &lt;!--&lt;mapper class=\"com.xushui.dao.AccountDao\"&gt;&lt;/mapper&gt;--&gt; &lt;package name=\"com.xushui.dao\"&gt;&lt;/package&gt; &lt;/mappers&gt;&lt;/configuration&gt; dao用注解形式配置 123456789101112131415public interface AccountDao { /** * 查询所有账户 * @return */ @Select(\"select * from account\") List&lt;Account&gt;findAll(); /** * 保存账户信息 * @param account */ @Insert(\"insert into account(name, money) values(#{name}, #{money})\") void saveAccount(Account account);} 测试Mybatis环境 123456789101112131415161718192021public class TestMybatis { @Test public void testFindAll() throws Exception { // 加载配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); // 创建SqlSessionFactory对象 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); // 创建SqlSession对象 SqlSession sqlSession = factory.openSession(); // 获取到代理对象 AccountDao accountDao = sqlSession.getMapper(AccountDao.class); // 查询所有 List&lt;Account&gt; accounts = accountDao.findAll(); for (Account account : accounts) { System.out.println(account); } // 关闭资源 sqlSession.close(); in.close(); }} 要注意的是增删改事务要记得提交 Spring整合Mybatis 在Spring的配置文件中配置Mybatis 12345678910111213141516&lt;!--Spring整合Mybatis框架--&gt;&lt;!--配置连接池--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///spring\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"*******\"/&gt;&lt;/bean&gt;&lt;!--配置SqlSessionFactory工厂--&gt;&lt;bean id=\"sessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置AccountDao接口所在包--&gt;&lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.xushui.dao\"&gt;&lt;/property&gt;&lt;/bean&gt; 当这边配置好后，就不再需要Mybatis的配置文件 配置好后为Dao接口加上注解@Repository 配置Spring的生命是事务管理在Spring配置文件添加123456789101112131415161718&lt;!--配置Spring框架声明式事务管理--&gt;&lt;!--配置事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--配置事务通知--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置AOP增强--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"pc1\" expression=\"execution(* com.xushui.service.Impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pc1\"/&gt;&lt;/aop:config&gt; 在AccountController中添加saveAccount方法,用request和response完成进行重定向到其他方法123456@RequestMapping(\"saveAccount\")public void saveAccount(Account account, HttpServletRequest request, HttpServletResponse response) throws Exception { accountService.saveAccount(account); response.sendRedirect(request.getContextPath()+\"/account/findAll\"); return;} 测试123456&lt;h3&gt;测试保存&lt;/h3&gt;&lt;form action=\"account/saveAccount\" method=\"post\"&gt; 名字:&lt;input type=\"text\" name=\"name\"&gt; 金额:&lt;input type=\"text\" name=\"money\"&gt; &lt;input type=\"submit\" value=\"提交保存\"&gt;&lt;/form&gt; 使用配置文件的方式搭建Mbatis12345678910111213141516&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///spring\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"******\"/&gt;&lt;/bean&gt;&lt;bean id=\"sessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!--使用配置形式，实现接口--&gt; &lt;property name=\"mapperLocations\" value=\"classpath:/mapper/*.xml\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.xushui.dao\"&gt;&lt;/property&gt;&lt;/bean&gt; AccountDao.xml12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xushui.dao.AccountDao\"&gt; &lt;select id=\"findAll\" resultType=\"com.xushui.domain.Account\"&gt; select * from account &lt;/select&gt; &lt;insert id=\"saveAccount\" parameterType=\"com.xushui.domain.Account\"&gt; insert into account(name, money) values(#{name}, #{money}) &lt;/insert&gt;&lt;/mapper&gt;","link":"/2019/08/09/SpringMVC学习笔记-3/"},{"title":"SpringMVC学习笔记(2)","text":"响应数据和结果视图 返回值分类String12345678910111213@RequestMapping(\"/testString\")public String testString(Model model){ System.out.println(\"testString方法执行了。。。\"); User user = new User(); user.setUsername(\"佩佩\"); user.setPassword(\"123123\"); user.setAge(18); model.addAttribute(\"user\", user); return \"success\";} void12345678910@RequestMapping(\"/testVoid\")public void testVoid(HttpServletRequest request, HttpServletResponse response) throws Exception { System.out.println(\"testVoid方法执行了。。。\"); // 1. request.getRequestDispatcher(\"/WEB-INF/pages/success.jsp\").forward(request,response); // 2. response.sendRedirect(\"testString\"); // 3. response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"application/json;charset=utf-8\"); response.getWriter().write(\"你好\");} ModelAndView1234567891011121314@RequestMapping(\"/testModelAndView\")public ModelAndView testModelAndView(){ System.out.println(\"testModelAndView方法执行了。。。\"); ModelAndView mv = new ModelAndView(); User user = new User(); user.setUsername(\"小佩\"); user.setPassword(\"123\"); user.setAge(18); // 把user对象存储到mv对象中，也会把user对象存入到request对象 mv.addObject(\"user\", user); // 跳转到哪个页面 mv.setViewName(\"success\"); return mv;} 转发和重定向1234567@RequestMapping(\"/testForwardAndRedirect\")public String testForwardAndRedirect(){ System.out.println(\"testForwardAndRedirect方法执行了。。。\"); // return \"forward:/WEB-INF/pages/success.jsp\"; return \"redirect:testString\";} @ResponseBody响应json数据 引入jquery和jacksonjar包 json字符串和JavaBean对象互相转换的过程中，需要使用jackson的jar包123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 配置前端控制器，让它不拦截静态资源 1234&lt;!-- 设置静态资源不过滤 --&gt;&lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;!-- 样式 --&gt; &lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt; &lt;!-- 图片 --&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;!-- javascript --&gt; 编写页面发送ajax请求 1234567891011121314151617181920$(function () { $(\"#btn\").click(function () { // alert(\"hello btn\"); // 发送ajax请求 $.ajax({ url:\"user/testAjax\", contentType:\"application/json;charset=UTF-8\", data:'{\"username\":\"myhere\",\"password\":\"123\",\"age\":30}', dataType:\"json\", type:\"post\", success:function (data) { // date服务器端响应的json的数据，进行解析 alert(data); alert(data.username); alert(data.password); alert(data.age); } }); });}) 编写UserController，通过@ResponseBody标签可以直接将返回值转换为json传至前端页面 1234567891011121314/** * 模拟异步请求 */@RequestMapping(\"/testAjax\")public @ResponseBody User testAjax(@RequestBody User user){ System.out.println(\"testAjax方法执行了。。。\"); // 客户端发送ajax请求，传的是json字符串，后端把字符串封装到user对象中 System.out.println(user); // 作响应，模拟数据库查询 user.setUsername(\"meng\"); user.setAge(20); // 作响应 return user;} Spring实现文件上传传统方式 导入文件上传的jar包 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 编写文件上传的JSP页面 12345&lt;h3&gt;文件上传&lt;/h3&gt;&lt;form action=\"user/fileupload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件:&lt;input type=\"file\" name=\"upload\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传文件\"/&gt;&lt;/form&gt; 编写文件上传的Controller控制器 1234567891011121314151617181920212223242526272829303132333435/*** 文件上传* @throws Exception */@RequestMapping(value=\"/fileupload\")public String fileupload(HttpServletRequest request) throws Exception { // 先获取到要上传的文件目录 String path = request.getSession().getServletContext().getRealPath(\"/uploads\"); // 创建File对象，一会向该路径下上传文件 File file = new File(path); // 判断路径是否存在，如果不存在，创建该路径 if(!file.exists()) { file.mkdirs(); } // 创建磁盘文件项工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload fileUpload = new ServletFileUpload(factory); // 解析request对象 List&lt;FileItem&gt; list = fileUpload.parseRequest(request); // 遍历 for (FileItem fileItem : list) { // 判断文件项是普通字段，还是上传的文件 if(fileItem.isFormField()) { }else { // 上传文件项 // 获取到上传文件的名称 String filename = fileItem.getName(); // 上传文件 fileItem.write(new File(file, filename)); // 删除临时文件 fileItem.delete(); } } return \"success\";} SpringMVC传统方式文件上传 配置文件解析器对象 1234&lt;!--文件解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"&gt;&lt;/property&gt;&lt;/bean&gt; 编写UserController 12345678910111213141516171819@RequestMapping(\"/fileUpload1\")public String fileUpload1(HttpServletRequest request, MultipartFile upload) throws Exception { System.out.println(\"SpringMVC文件上传\"); // 文件位置 String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); File file = new File(path); if (!file.exists()){ // 如果没有这个文件夹就创建这个文件夹 file.mkdirs(); } // 获取上传文件名 String filename = upload.getOriginalFilename(); // 将文件名称设置为唯一值 String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid + \"_\" + filename; upload.transferTo(new File(path,filename)); return \"success\";} 跨服务器文件上传 导入坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; 配置文件解析器对象 1234&lt;!--文件解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"&gt;&lt;/property&gt;&lt;/bean&gt; index.jsp 12345&lt;h3&gt;跨服务器文件上传&lt;/h3&gt;&lt;form action=\"user/fileUpload2\" method=\"post\" enctype=\"multipart/form-data\"&gt; 请选择文件:&lt;input type=\"file\" name=\"upload\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;/form&gt; UserController 1234567891011121314151617181920212223/** * 跨服务器文件上传 * @param upload 这个名称必须和文件项的name一模一样 * @return */@RequestMapping(\"/fileUpload2\")public String fileUpload2(MultipartFile upload) throws Exception { System.out.println(\"跨服务器文件上传\"); //定义上传文件服务器路径 String path = \"http://localhost:9090/uploads/\"; // 获取上传文件名 String filename = upload.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename = uuid + \"_\" + filename; // 创建客户端对象 Client client = Client.create(); // 和图片服务器进行连接 WebResource webResource = client.resource(path + filename); // 上传文件 webResource.put(upload.getBytes()); return \"success\";} 异常处理 编写自定义异常类 12345678910111213141516171819/** * 自定义异常类 */public class SysException extends Exception { private String message; @Override public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public SysException(String message) { this.message = message; }} 编写异常处理器 123456789101112131415161718192021222324252627/** * 异常处理器 */public class SysExceptionResolver implements HandlerExceptionResolver { /** * 处理异常的业务逻辑 * @param httpServletRequest * @param httpServletResponse * @param o * @param e * @return */ @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) { SysException sysException = null; if (e instanceof SysException){ sysException = (SysException) e; } else { sysException = new SysException(\"系统正在维护!\"); } ModelAndView mv = new ModelAndView(); mv.addObject(\"errorMsg\", sysException.getMessage()); mv.setViewName(\"error\"); return mv; }} 配置异常处理器 12&lt;!--配置异常处理器--&gt;&lt;bean id=\"eptionResolver\" class=\"com.xushui.exception.SysExceptionResolver\"&gt;&lt;/bean&gt; SpringMVC拦截器拦截器作用 Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 用户可以自己定义一些拦截器来实现特定的功能。 谈到拦截器，还要向大家提一个词——拦截器链(Interceptor Chain)。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 拦截器和过滤器的区别: 过滤器是servlet规范中的一部分，任何java web工程都可以使用。 拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。 过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。 它也是 AOP 思想的具体应用。 我们要想自定义拦截器， 要求必须实现:HandlerInterceptor 接口。 自定义拦截器的步骤 编写拦截器，实现HandlerInterceptor接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyInterceptor implements HandlerInterceptor { /** * 预处理，Controller方法执行前 * @param request * @param response * @param handler * @return * true: 放行，执行下一个拦截器，如果没有，执行Controller方法 * false: 不放行，可以用request或者response转发 * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"拦截器预处理方法执行了111111\"); // request.getRequestDispatcher(\"/WEB-INF/pages/error.jsp\").forward(request, response); return true; } /** * 后处理方法，Controller执行之后，success.jsp执行方法之前 * @param request * @param response * @param handler * @param modelAndView * @throws Exception */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"拦截器后处理方法执行了11111\"); } /** * success.jsp页面执行后，该方法会执行 * @param request * @param response * @param handler * @param ex * @throws Exception */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"拦截器afterCompletion方法执行了....1111111\"); }} 在bean.xml中配置拦截器 12345678910111213141516171819202122&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--配置拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体方法--&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!--不要拦截的方法--&gt; &lt;!--&lt;mvc:exclude-mapping path=\"\"&gt;&lt;/mvc:exclude-mapping&gt;--&gt; &lt;!--配置拦截器对象--&gt; &lt;bean id=\"myInterceptor\" class=\"com.xushui.interceptor.MyInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;!--配置第二个拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体方法--&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!--不要拦截的方法--&gt; &lt;!--&lt;mvc:exclude-mapping path=\"\"&gt;&lt;/mvc:exclude-mapping&gt;--&gt; &lt;!--配置拦截器对象--&gt; &lt;bean id=\"myInterceptor2\" class=\"com.xushui.interceptor.MyInterceptor2\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 当配置了两个拦截器后执行结果 12345678拦截器预处理方法执行了111111拦截器预处理方法执行了222222testInterceptor执行...拦截器后处理方法执行了22222拦截器后处理方法执行了11111success.jsp执行了...拦截器afterCompletion方法执行了....22222拦截器afterCompletion方法执行了....1111111 拦截器中断流程拦截器一放行拦截器二不放行，那么执行结果将是123拦截器预处理方法执行了111111拦截器预处理方法执行了222222拦截器afterCompletion方法执行了....1111111","link":"/2019/08/08/SpringMVC学习笔记-2/"},{"title":"Spring学习笔记(3)","text":"动态代理 特点: 字节码随用随创建，随用随加载 作用: 不修改源码的基础下，使方法增强 分类: 基于接口的动态代理 基于子类的动态代理 基于接口的动态代理 涉及的类: Proxy 提供者: JDK 如何创建代理对象 使用Proxy类中的newProxyInstance方法 创建代理对象的要求 被代理对象最少实现一个接口，如果没有则不能使用 newProxyInstance方法的参数: ClassLoader: 类加载器 它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器(就是你要代理谁，就写谁的类加载器)【固定写法】 Class[]: 字节码数组 它是用于让代理对象和被代理对象有相同方法【固定写法】 InvocationHandler: 用于提供增强的代码 它是让我们写如何代理，一般都是写一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的 此接口的实现类是谁用谁写 基于接口动态代理的一个例子当我们的类不实现接口的时候，是不能用动态代理的123456789101112131415161718192021222324252627public static void main(String[] args) { final Producer producer = new Producer(); IProducer proxyProduce = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() { /** * 作用:执行被代理的对象的任何接口方法都会经过该方法 * 方法参数的含义 * @param proxy * @param method 当前执行的方法 * @param args 当前执行的方法所需的参数 * @return 和被代理对象方法有相同的返回值 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 提供增强的代码 Object returnValue = null; // 1.获取方法执行的参数 Float money = (Float) args[0]; // 2.判断当前方法是不是销售 if (\"saleProduct\".equals(method.getName())){ returnValue = method.invoke(producer, money*0.8f); } return returnValue; } }); proxyProduce.saleProduct(10000); } 基于子类的动态代理需要第三方JAR包的支持12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.1_3&lt;/version&gt;&lt;/dependency&gt; 涉及的类: Enhancer 提供者: 第三方类库cglib 如何创建代理对象 使用Enhancer类中的create方法 创建代理对象的要求 被代理类不能是最终类(最终类就不能创建子类了) create方法的参数: Class: 字节码 用于指定被代理对象的字节码 Callback: 用于提供增强的代码 它是让我们写如何代理，一般都是写一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的 此接口的实现类是谁用谁写 我们一般写的都是该接口的子接口实现类: MethodInterceptor 代码实现12345678910111213141516171819202122232425262728public static void main(String[] args) { final Producer producer = new Producer(); Producer proxyProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() { /** * 执行被代理对象的任何方法都会经过该方法 * @param proxy 代理对象的引用 * @param method 当前执行的方法 * @param args 当前执行的方法所需的参数 * 以上三个参数和基于接口的动态代理是一样的 * @param methodProxy 当前执行方法的代理对象 * @return * @throws Throwable */ public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { // 提供增强的代码 Object returnValue = null; // 1.获取方法执行的参数 Float money = (Float) args[0]; // 2.判断当前方法是不是销售 if (\"saleProduct\".equals(method.getName())){ returnValue = method.invoke(producer, money*0.8f); } return returnValue; } }); proxyProducer.saleProduct(10000); } 通过动态代理改善代码即实现了简化开发，又实现了事务控制1234567891011121314151617181920212223242526272829303132333435363738394041/** * 用于创建Service代理对象的工厂 */public class BeanFactory { private AccountService accountService; private TransactionManager txManager; public void setTxManager(TransactionManager txManager) { this.txManager = txManager; } public final void setAccountService(AccountService accountService) { this.accountService = accountService; } public AccountService getAccountService(){ return (AccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object rtValue = null; try { // 1.开启事务 txManager.beginTransaction(); // 2.执行操作 rtValue = method.invoke(accountService, args); // 3.提交事务 txManager.commit(); // 4.返回结果 return rtValue; } catch (Exception e){ // 5.回滚操作 txManager.rollback(); throw new RuntimeException(e); } finally { // 6.释放连接 txManager.release(); } } }); }} AccountServiceImpl123456789101112131415public void transfer(String sourceName, String targetName, Integer money) { System.out.println(\"transfer\"); Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targetName); source.setMoney(source.getMoney() - money); target.setMoney(target.getMoney() + money); accountDao.updateAccount(source);// int i = 1/0; accountDao.updateAccount(target); } 测试类123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:bean.xml\")public class AccountServiceTest { @Autowired @Qualifier(\"proxyAccountService\") private AccountService accountService; @Test public void testTransfer() { accountService.transfer(\"aaa\", \"bbb\", 100); }} bean.xml123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--配置代理的Service--&gt; &lt;bean id=\"proxyAccountService\" factory-bean=\"beanFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; &lt;!--配置BeanFactory--&gt; &lt;bean id=\"beanFactory\" class=\"com.xushui.factory.BeanFactory\"&gt; &lt;property name=\"txManager\" ref=\"transactionManager\"&gt;&lt;/property&gt; &lt;property name=\"accountService\" ref=\"accountService\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; ...","link":"/2019/08/04/Spring学习笔记-3/"},{"title":"Spring学习笔记(5)","text":"Spring中的Template使用xml配置 直接继承JdbcDaoSupport就可以不写template12345678910111213141516171819202122232425public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao { @Override public Account findAccountById(int id) { List&lt;Account&gt; account = getJdbcTemplate().query(\"select * from account where id=?\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id); return account.isEmpty()?null:account.get(0); } @Override public Account findAccountByName(String name) { List&lt;Account&gt; account = getJdbcTemplate().query(\"select * from account where name = ?\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (account.isEmpty()){ return null; } if (account.size() &gt; 1){ throw new RuntimeException(\"结果集不唯一\"); } return account.get(0); } @Override public void updateAccount(Account account) { getJdbcTemplate().update(\"update account set name=?,money=? where id=?\", account.getName(), account.getMoney(), account.getId()); }} 使用注解配置使用注解配置时，因为无法给jar包中的template加上注解，所以采用这种方式123456789101112131415161718192021222324252627@Repositorypublic class AccountDaoImpl2 implements AccountDao { @Autowired JdbcTemplate template; @Override public Account findAccountById(int id) { List&lt;Account&gt; account = template.query(\"select * from account where id=?\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), id); return account.isEmpty()?null:account.get(0); } @Override public Account findAccountByName(String name) { List&lt;Account&gt; account = template.query(\"select * from account where name = ?\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), name); if (account.isEmpty()){ return null; } if (account.size() &gt; 1){ throw new RuntimeException(\"结果集不唯一\"); } return account.get(0); } @Override public void updateAccount(Account account) { template.update(\"update account set name=?,money=? where id=?\", account.getName(), account.getMoney(), account.getId()); }} Spring中的事务控制事务控制也是基于aspectjweaver(重要) Spring中基于XML的声明式事务控制配置步骤 配置事务管理器 配置事务的通知 此时我们需要导入事务的约束 tx和aop名称空间和约束 使用tx:advice标签配置事务通知 属性: id: 事务通知的唯一标识 transaction-manager: 给事务通知提供一个事务管理器的引用12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 配置AOP中的通用切入点表达式 建立事务通知和切入点表达式的对应关系 配置事物的属性 在tx:advice标签的内部 isolation:用于指定事物的隔离级别，默认值是DEFAULT，表示使用数据库的默认隔离级别 propagation: 用于指定事务的传播行为，默认值是REQUIRED，表示一定会有事务，增删改选择，查询方法的话可以选择SUPPORTS read-only: 用于指定事务是否只读，只有查询方法才能设置为true，默认值为false，表示读写 rollback-for: 用于指定一个异常，产生该异常时事务回滚，产生其他异常时，事务不回滚。没有默认值，表示任何异常都回滚 no-rollback-for: 用于指定一个异常，产生该异常时事务不回滚，产生其他异常时，事务回滚。没有默认值，表示任何异常都回滚 timeout: 用于指定事务的超时，默认值是-1，表示永不超时，如果指定了数值，以秒为单位 示例12345678910111213141516171819202122&lt;!--配置事务管理器--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务的通知--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!--配置事务的属性--&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;!--遵循查询方法都以find开头，就可以很方便配置--&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id=\"pc1\" expression=\"execution(* com.xushui.service.Impl.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--建立切入点表达式和事务通知的对应关系--&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pc1\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; Spring中基于注解的声明式事务控制配置步骤 配置事务管理器 开启Spring对注解事务的支持 在需要开启事务支持的地方使用@Transactional注解 示例123456&lt;!--配置事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启Spring对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"&gt;&lt;/tx:annotation-driven&gt; 纯注解方式可以加上@EnableTransctionManagement注解实现开启Spring对注解事务的支持","link":"/2019/08/06/Spring学习笔记-5/"},{"title":"SpringMVC学习笔记(1)","text":"三层架构和MVC三层架构 服务器端程序，一般基于两种形式，一种C/S架构程序，一种B/S架构程序 使用Java语言基本上都是开发B/S架构的程序，B/S架构又分成了三层架构 三层架构 表现层:WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型 业务层:处理公司具体的业务逻辑的 持久层:用来操作数据库的 MVC模型 MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。 Model:数据模型，JavaBean的类，用来进行数据封装。 View:指JSP、HTML用来展示数据给用户 Controller:用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 SpringMVC入门 导入jar包 123456789101112131415161718192021222324252627282930313233&lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在web.xml配置核心控制器 1234567891011121314151617&lt;!-- SpringMVC的核心控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置Servlet的初始化参数，读取springmvc的配置文件，创建spring容器 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置servlet启动时加载 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!-- 拦截所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在springmvc.xml中导入约束 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置spring创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置spring开启注解mvc的支持--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 控制器 123456789101112131415/*** 控制器* @author */@Controllerpublic class HelloController {/*** 接收请求 * @return */ @RequestMapping(path=\"/hello\") public String sayHello() { System.out.println(\"Hello SpringMVC!!\"); return \"success\"; }} @RequestMapping 作用: 用于建立请求 URL 和处理请求方法之间的对应关系。 功能: 可以在类上添加注解(表示一级目录)，也可以在方法上添加(表示二级目录) 属性: value: 和path一样，用来指定请求的 URL method: 用于指定请求的方式(POST, GET等) 一般超链接使用的是GET请求方式 params: 用于指定限制请求参数的条件，支持简单的表达式，要求请求参数的key和value必须和配置的一模一样 header: 用于指定限制请求消息头的条件 这些属性只要同时出现就是与的关系 请求参数绑定HelloController123456@RequestMapping(value = \"/login\", params = {\"username\",\"password\"})public String login(String username, String password) { System.out.println(\"用户名为: \" + username); System.out.println(\"密码为: \" + password); return \"success\";} index.jsp12345&lt;form method=\"get\" action=\"user/login\"&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;input type=\"text\" id=\"password\" name=\"password\"&gt; &lt;button type=\"submit\" id=\"button\"&gt;登录&lt;/button&gt;&lt;/form&gt; 支持的数据类型 基本类型参数: 包括基本类型和 String 类型 POJO(JavaBean) 类型参数: 包括实体类，以及关联的实体类 数组和集合类型参数 : 包括 List 结构和 Map 结构的集合(包括数组) SpringMVC 绑定请求参数是自动实现的，但是要想使用，必须遵循使用要求。 JavaBean类型请求参数绑定AccountController123456789101112131415@Controller@RequestMapping(\"/account\")public class AccountController { /** * 请求参数绑定把数据封装到JavaBean的类中 * @param account * @return */ @RequestMapping(value = \"/saveAccount\", method = RequestMethod.POST, params = {\"username\", \"password\", \"money\"}) public String saveAccount(Account account){ System.out.println(\"保存了\"); System.out.println(account); return \"success\"; }} Account12345678public class Account implements Serializable { private String username; private String password; private Double money; //在一个实体类中的实体变量 private User user; ...} 注意 要注意的就是要保证name和你要封装的JavaBean的变量名一直，可以自动完成封装。 要给实体类中的引用类型赋值时，只用使用引用类型的变量名.变量名即可12345678&lt;form method=\"post\" action=\"account/saveAccount\"&gt; 用户名:&lt;input type=\"text\" id=\"username\" name=\"username\"&gt;&lt;br&gt; 密码:&lt;input type=\"text\" id=\"password\" name=\"password\"&gt;&lt;br&gt; 金额:&lt;input type=\"text\" id=\"money\" name=\"money\"&gt;&lt;br&gt; 用户姓名:&lt;input type=\"text\" id=\"uname\" name=\"user.uname\"&gt;&lt;br&gt; 用户年龄:&lt;input type=\"text\" id=\"age\" name=\"user.age\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 解决Post请求中文乱码问题在web.xml中配置一个过滤器12345678910111213&lt;!--配置解决中文乱码问题的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 集合类型请求参数绑定 List形式只要直接用集合名[索引].变量名即可 Map形式只要直接用集合名[key].变量名即可123456789101112&lt;form method=\"post\" action=\"account/saveAccount\"&gt; 用户名:&lt;input type=\"text\" id=\"username\" name=\"username\"&gt;&lt;br&gt; 密码:&lt;input type=\"text\" id=\"password\" name=\"password\"&gt;&lt;br&gt; 金额:&lt;input type=\"text\" id=\"money\" name=\"money\"&gt;&lt;br&gt; 用户姓名:&lt;input type=\"text\" name=\"list[0].uname\"&gt;&lt;br&gt; 用户年龄:&lt;input type=\"text\" name=\"list[0].age\"&gt;&lt;br&gt; 用户姓名:&lt;input type=\"text\" name=\"map['one'].uname\"&gt;&lt;br&gt; 用户年龄:&lt;input type=\"text\"name=\"map['one'].age\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 自定义类型转换器Spring框架自带的类型转换器无法将2018-08-08格式的日期封装到Date中123456&lt;form method=\"post\" action=\"account/saveUser\"&gt; 用户姓名:&lt;input type=\"text\" name=\"uname\"&gt;&lt;br&gt; 用户年龄:&lt;input type=\"text\"name=\"age\"&gt;&lt;br&gt; 用户生日:&lt;input type=\"text\"name=\"birthday\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 123456public class User implements Serializable { private String uname; private Integer age; private Date birthday; ...} 因此我们需要自己定义一个类，实现Converter&lt;S,T&gt;接口，将特定格式的String类型的日期转换为Date类型123456789101112131415public class DateConverter implements Converter&lt;String, Date&gt; { @Override public Date convert(String source) { try { if (source == null){ throw new RuntimeException(\"请传入日期数据\"); } DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = df.parse(source); return date; } catch (ParseException e) { throw new RuntimeException(e); } }} 完成后我们需要在Spring配置文件中配置类型转换器，在mvc:annotation-driven标签中，conversion-service标签中引入自定义类型转换器123456789101112&lt;!-- 配置类型转换器工厂 --&gt;&lt;bean id=\"conversionService1\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;!-- 给工厂注入一个新的类型转换器 --&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;!-- 添加自定义类型转换器 --&gt; &lt;bean id=\"dateConverter\" class=\"com.xushui.utils.DateConverter\"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--开启Spring注解支持 引用自定义类型转换器--&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService1\"&gt;&lt;/mvc:annotation-driven&gt; 这样就完成了自定义的类型转换 获取Servlet原生API你想获取Servlet的request或者response，你就在参数上加上他们，Spring框架会自动帮你获取12345678910111213@RequestMapping(\"testRequest\") public String testRequest(HttpServletRequest request, HttpServletResponse response) { System.out.println(request); HttpSession session = request.getSession(); System.out.println(session); ServletContext servletContext = session.getServletContext(); System.out.println(servletContext); System.out.println(response); return \"success\"; } 常用注解@RequestParam 作用位置: 参数上 作用: 把请求中指定名称的参数给控制器中的形参赋值 属性: value: 请求参数中的名称(可以和参数列表的名字不同) required: 请求参数中是否必须提供次参数。默认值true，表示必须提供，不提供就报错。 123456@RequestMapping(\"testRequestParam\") public String testRequestParam(@RequestParam(\"name\") String username){ System.out.println(\"用户名: \" + username); System.out.println(\"testRequestParam执行了...\"); return \"success\"; } 使用此注解后，传入参数名称一定要与value中的相同 @RequestBody 作用位置: 参数上 作用: 用于获取请求体的内容。直接使用的到key=value&amp;key=value..结构的数据 (get请求方式不适用) 属性: required: 是否必须有请求体。默认是true，此时get请求方式会报错。如果为false，get请求得到的是null 12345678910/** * 获取请求体内容 * @return */@RequestMapping(\"testRequestBody\")public String testRequestBody(@RequestBody String body){ System.out.println(\"testRequestBody执行了...\"); System.out.println(body); return \"success\";} @PathVaribale 作用位置: 参数上 作用: 用于绑定 URL 中的占位符，获取占位符中的数据 属性: value: 用于指定 URL 中占位符名称 required: 是否必须提供占位符 12345678910/** * PathVariable注解 * @return */@RequestMapping(\"/testPathVariable/{id}\")public String testPathVariable(@PathVariable(\"id\") String id){ System.out.println(\"testPathVariable执行了...\"); System.out.println(\"id为\" + id); return \"success\";} @RequestHeader(不常用) 作用位置: 参数上 作用: 用于获取请求消息头 属性: value: 提供消息头名称 required: 是否必须有此消息头 12345678910/** * RequestHeader注解 * @return */@RequestMapping(\"/testRequestHeader\")public String testRequestHeader(@RequestHeader(\"Accept\") String accept){ System.out.println(\"RequestHeader执行了...\"); System.out.println(\"accept为\" + accept); return \"success\";} @CookieValue 作用位置: 参数上 作用: 用于把指定cookie名称的值传入控制器方法参数 属性: value: 提供cookie的名称 required: 是否必须有此cookie 12345678910/** * CookieValue注解 * @return */@RequestMapping(\"/testCookieValue\")public String testCookieValue(@CookieValue(\"JSESSIONID\") String cookie){ System.out.println(\"RequestHeader执行了...\"); System.out.println(\"cookie为\" + cookie); return \"success\";} @ModelAttribute 作用位置: 方法上 作用: 方法会在控制器的方法执行之前，先执行。有返回值或者无返回值都可以修饰。 应用场景: 我们在编辑一个用户时， 用户有一些该字段的值是不允许被修改的。在提交表 单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。123456789101112131415161718192021222324/** * ModelAttribute注解 * @return */@RequestMapping(\"/testModelAttribute\")public String testModelAttribute(User user){ System.out.println(\"testModelAttribute执行了...\"); System.out.println(user); return \"success\";}@ModelAttributepublic User showUser(String uname, String age) { // 模拟数据库查询 User user = new User(); user.setUname(\"赵四\"); user.setAge(18); user.setBirthday(new Date()); user.setUname(uname); user.setAge(Integer.parseInt(age)); return user; } 参数上 作用: 用于获取指定的数据给参数赋值123456789101112131415161718192021222324/** * ModelAttribute注解 * @return */@RequestMapping(\"/testModelAttribute\")public String testModelAttribute(@ModelAttribute(\"abc\") User user){ System.out.println(\"testModelAttribute执行了...\"); System.out.println(user); return \"success\";}@ModelAttributepublic void showUser(String uname, String age, Map&lt;String, User&gt; map) { // 模拟数据库查询 User user = new User(); user.setUname(\"赵四\"); user.setAge(18); user.setBirthday(new Date()); user.setUname(uname); user.setAge(Integer.parseInt(age)); map.put(\"abc\", user);} 属性: value: 用于获取数据的key。key可以是POJO的属性名称，也可以是map结构的key。 @SessionAttributes 作用位置: 类上 作用: 用于多次执行控制器方法间的参数共享(将参数存到session域中) 属性: value: 用于指定存入的属性名称 type: 用于指定存入的数据类型 1234567891011121314151617181920212223242526272829303132333435363738@Controller@RequestMapping(\"/anno\")@SessionAttributes(\"msg\")//将msg存入到session域中public class AnnoController { /** * SessionAttributes注解 * @return */ @RequestMapping(\"/testSessionAttributes\") public String testSessionAttributes(Model model){ System.out.println(\"testSessionAttributes执行了...\"); // 底层会存储到request域对象中 model.addAttribute(\"msg\",\"佩佩\"); return \"success\"; } /** * 取出Session中的值 * @return */ @RequestMapping(\"/getSessionAttributes\") public String getSessionAttribute(ModelMap modelMap){ System.out.println(\"getSessionAttribute执行了...\"); String msg = (String) modelMap.get(\"msg\"); System.out.println(msg); return \"success\"; } /** * 清除Session域中的值 * @return */ @RequestMapping(\"/delSessionAttributes\") public String delSessionAttributes(SessionStatus status){ System.out.println(\"delSessionAttributes执行了...\"); status.setComplete(); return \"success\"; }","link":"/2019/08/07/SpringMVC学习笔记-1/"},{"title":"Spring学习笔记(1)","text":"Spring的概述Spring是什么Spring是分层的Java SE/EE应用 full-stack轻量级开源框架，以IoC(Inverse Of Control:反转控制)和AOP(Aspect Oriented Programming:面向切面编程)为内核，提供展现层 SpringMVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库。 程序耦合以及解耦 程序的耦合 耦合: 程序间的依赖关系 包括: 类之间的依赖 方法间的依赖 解耦: 降低程序间的依赖关系 实际开发中: 应该做到编译期不依赖，运行时才依赖 解耦思路: 使用反射来创建对象，而避免用new 通过读取配置文件来获取要创建对象的全限定类名 用工厂模式创建对象(解耦)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 一个创建Bean对象的工厂 * * Bean: 在计算机英语中，有可重用组件的含义。 * JavaBean: 用Java语言编写的可重用组件 * JavaBean &gt; 实体类 * * 他就是创建service和dao对象的。 * * 1. 需要一个配置文件来配置service和dao * 配置的内容: 唯一标志=全限定类名(key=value) * 2. 通过读取配置文件中的配置的内容，反射创建对象 * * 配置文件可以是xml也可以是properties */public class BeanFactory { // 定义一个Properties对象 private static Properties prop; // 定义一个Map，用于存放我们要创建的对象。我们把它称之为容器 private static Map&lt;String, Object&gt; beans; // 使用静态代码块为Properties对象赋值 static { try { prop = new Properties(); // 获取properties文件的流对象【一定要用类加载器来访问，不然程序一旦部署就找不到，放在resources下的配置文件，最后会成为根路径下的文件】 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(\"bean.properties\"); prop.load(in); // 实例化容器 beans = new HashMap&lt;String, Object&gt;(); // 取出配置文件中所有的key Enumeration&lt;Object&gt; keys = prop.keys(); // 遍历枚举 while (keys.hasMoreElements()) { // 取出每个key String key = keys.nextElement().toString(); // 根据key获取value String beanPath = prop.getProperty(key); // 反射创建对象 Object value = Class.forName(beanPath).newInstance(); // 把key和value存入容器中 beans.put(key, value); } } catch (Exception e) { // 没有读取到这个配置文件，直接抛出异常。无法继续进行下去。 throw new ExceptionInInitializerError(\"初始化properties失败\"); } } /** * 用这种方式将方法名和Bean存放在HashMap中，通过key(方法名)来取出对象。这样的对象是单例的 * @param beanName * @return */ public static Object getBean(String beanName) { return beans.get(beanName); } 有了这样的工厂就可以通过AccountService service = (AccountService) BeanFactory.getBean(&quot;accountService&quot;);方式来创建对象，就是将创建对象的控制权交给了工厂，这就是控制反转 通过这种方式降低了程序之间的耦合 IOC的概念和Spring中的IOC控制反转(IOC)把对象创建的权利交给了框架，是框架的重要特征，它包括了依赖注入(DI)和依赖查找(Dependency Lookup)。其主要作用就是削减计算机程序的耦合(程序间的依赖关系) Spring中基于XML的IOC环境搭建 在pom.xml的依赖中加入 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 然后在resources中创建一个bean.xml文件并导入约束 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 把对象的创建交给Spring来管理 12&lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.xushui.dao.Impl.AccountDaoImpl\"&gt;&lt;/bean&gt; 4.测试代码123456789101112131415/** * 获取spring的IOC核心容器，并根据id获取对象 * @param args */ public static void main(String[] args) { // 1.获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); // 2.根据id获取bean对象 AccountService accountService = (AccountService) ac.getBean(\"accountService\"); // 两种方式都可以，一种是强制转换，一种是加上你要转的类的字节码文件 AccountDao accountDao = ac.getBean(\"accountDao\",AccountDao.class); System.out.println(accountService); System.out.println(accountDao); } 一些要注意的地方ApplicationContext的三个常用实现类1. ClassPathXmlApplicationContext: 它可以加载类路径下的配置文件，要求配置文件必须在类路径下(常用) 2. FileSystemXmlApplicationContext: 它可以加载磁盘任意路径下的配置文件(必须有访问权限) 3. AnnotationConfigApplicationContext: 它是用于读取注解创建容器的 核心容器的两个接口引发的问题ApplicationContext(大多数采用这个): 单例对象适用 它在构建核心容器时，创建对象采取的策略是立即加载的方式(一读取完配置文件马上创建配置文件中配置的对象) Spring是个很智能的框架，当你选择作用范围为prototype时，它会自动变为延迟加载策略 BeanFactory: 多例对象适用 它在构建核心容器时，采用的是延迟加载的策略(什么时候根据id获取对象了，什么时候才创建对象) Spring对bean管理的细节创建bean的三种方式 使用默认构造函数创建，若类中没有默认构造方法，则对象无法创建 1&lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt;&lt;/bean&gt; 使用普通工厂中的方法创建对象(使用某个类中的方法创建对象，并存入spring容器) 12&lt;bean id=\"instanceFactory\" class=\"com.xushui.factory.InstanceFactory\"&gt;&lt;/bean&gt;&lt;bean id=\"accountService\" factory-bean=\"instanceFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; 使用工厂中的静态方法创建对象(使用某个类的静态方法创建对象，并存入spring容器) 1&lt;bean id=\"accountService\" class=\"com.xushui.factory.StaticFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; bean对象的作用范围bean作用范围调整 bean标签的scope属性: 作用:用于指定bean的作用范围 取值: 前两个比较常用 singleton: 单例的(默认值) prototype: 多例的 request: 作用于web项目的请求范围 session: 作用于web项目的会话范围 global-session: 作用于集群环境的会话范围(全局会话范围)，当不是集群环境时，他就是session bean对象的生命周期 单例对象 出生: 当容器创建时，对象出生 活着: 只要容器还在，对象一直活着 死亡: 容器销毁，对象死亡 总结: 单例对象的生命周期和容器相同 多例对象 出生: 当我们使用对象时，Spring框架为我们创建 活着: 对象只要是在使用过程中。一直是活着 死亡: 当对象长时间没用，且没有别的对象引用，由Java的垃圾回收机制回收 依赖注入(Dependency Injection) 依赖关系的管理: 都交由Spring框架来维护 当前类需要其他类的对象，由Spring提供，我们只用在配置文件中说明 依赖关系的维护我们就称之为依赖注入 注意: 经常变化的数据，并不适合注入方式 支持注入的数据类型 基本类型和String 其他bean类型(配置文件中或者注解配置过的bean) 复杂类型/集合类型 注入类型 使用构造函数提供 使用set方法提供 使用注解提供 构造函数的注入 使用的标签: constructior-arg 标签出现的位置: bean标签的内部 标签中的属性 type: 用于指定要注入的数据的数据类型，该数据赋值给构造函数中该数据类型的一个或多个 index: 用于给构造函数中指定索引位置的参数赋值 索引从0开始 name: (常用)用于给构造函数中指定名字的参数赋值 value: 用于提供String类型和基本类型的数据 ref: 用于指定其他bean类的数据，值得就是Spring的IOC核心容器中出现过的bean对象 示例123456789101112131415public class AccountServiceImpl implements AccountService { private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday){ this.name = name; this.age = age; this.birthday = birthday; } public void saveAccount() { System.out.println(\"保存了 \" + \"名字: \" + name +\", 年龄: \"+age+\", 生日: \" + birthday); }} bin.xml中 1234567&lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 优势: 在获取bean对象时，注入数据是必须的操作，否则对象无法创建。弊端: 改变了bean的实例化方式，即使我们在创建对象时，用不到这些数据，也必须提供 set方法注入(常用) 使用的标签: property 出现的位置: bean标签的内部 标签属性: name:用于指定注入时所调用set的方法的名称 value和ref与构造函数注入一样 优势: 创建对象是没有明确的限制，可以直接使用默认的构造函数弊端: 如果有某个成员必须有值，set方法无法保证 复杂类型/集合类型注入12345678910111213141516171819202122232425262728293031323334353637&lt;bean id=\"accountService3\" class=\"com.xushui.service.Impl.AccountServiceImpl3\"&gt; &lt;property name=\"myStrs\"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;set&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"keyA\" value=\"aaa\"&gt;&lt;/entry&gt; &lt;entry key=\"keyB\"&gt;&lt;value&gt;bbb&lt;/value&gt;&lt;/entry&gt; &lt;entry key=\"keyC\" value=\"ccc\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;props&gt; &lt;prop key=\"AAA\"&gt;bbb&lt;/prop&gt; &lt;prop key=\"CCC\"&gt;Ddd&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 用于给List结构集合注入标签: list、array、set 用于给Map结构集合注入标签: map、props 结构相同标签可以互换","link":"/2019/08/01/Spring学习笔记-1/"},{"title":"Spring学习笔记(4)","text":"AOPAOP概述全称是Aspect Oriented Programming(面向切面编程)，可以做到把我们程序重复的代码抽取出来，在需要执行的时候，采用动态代理技术，在不修改源码的基础上，对我们已有的方法进行增强 Spring中的AOP 在Spring中，框架会根据目标类是否实现类接口来决定采用哪种动态代理的方式 通过配置的方式来实现动态代理 AOP相关术语 Joinpoint(连接点): 所谓的连接点是指那些被拦截到的点。在Spring中，这些点指的是方法，因为Spring只支持方法类型的连接点 通俗一点讲就是打开业务层接口，在业务层接口中看到的方法全都是连接点，就是连接业务和增强方法的那个点 Pointcut(切入点): 是指我们要对哪些Joinpoint进行拦截的定义 通俗来讲，在业务层接口中一个方法如果没有被增强，它就只是连接点，不是切入点。只有被增强了才是切入点 Advice(通知/增强): 所谓通知是指拦截到Joinpoint之后要做的事就是通知 通知的类型: 前置通知，后置通知，异常通知，最终通知，环绕通知 Introduction (引介): 引介是一种特殊的通知，在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或者成员变量 Target(目标对象): 代理的目标对象(被代理对象) Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程(比如说给Service加入事务支持的过程) Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 Proxy(代理): 一个类被AOP织入增强后，就产生一个结果代理类(代理对象) Aspect(切面): 是切入点和通知(引介)的结合 Spring中基于XML的AOP配置导入约束在Spring文档中搜索xmlns:aop，将约束导入bean.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 配置AOP 把通知Bean也交给Spring来管理 使用aop:config标签表明开始AOP的配置 使用aop:aspect标签开始配置切面 id属性: 给切面提供一个唯一标志 ref属性: 指定通知类bean的id 在aop:aspect标签内配置通知的类型 我们要让logger在切入点方法执行之前执行，所以要选用前置通知 aop:before标签: 表示配置前置通知 method属性: 指定哪个方法是前置通知 pointcut属性: 用于指定切入点表达式，含义是指对业务层哪些方法进行增强 切入点表达式的写法 关键字: execution(表达式) 表达式: 访问修饰符 返回值 全限定类名.方法名(参数列表) 标准表达式写法: public void com.xushui.service.Impl.AccountServiceImpl.saveAccount() 通配符写法: 访问修饰符可以省略 void com.xushui.service.Impl.AccountServiceImpl.saveAccount() 返回值可以用通配符表示任意返回值 * com.xushui.service.Impl.AccountServiceImpl.saveAccount() 包名可以使用通配符，表示任意包。有几级包，就要写几个*. * *.*.*.*.AccountServiceImpl.saveAccount() 包名还可以用..表示当前包及其子包(表示任一包下的AccountServiceImpl的saveAccount()方法都会被增强) * *..AccountServiceImpl.saveAccount() 类名和方法名都可以实现统配 * *..*.*(): 表示所有包下所有没有参数的方法都被增强 参数列表 基本类型直接写名称: int 应用类型写全限定类名: java.util.String 可以用通配符(*)表示任意类型，但是必须有参数(没有参数的不会被增强) * *..*.*(*) 可以使用..表示有无参数均可，有参数的话可以是任何类型 全通配写法: * *..*.*(..) 实际开发中切入点表达式的通常写法: 切到业务层实现类下的所有方法 * com.xushui.service.Impl.*.*(..) 配置表达式标签&lt;aop:pointcut&gt; id属性: 用于指定表达式的唯一标识 expression: 用于指定表达式内容 这个标签可以写在&lt;aop:aspect&gt;标签上面(不能写在下面会报错)，这样子所有的切面都可以使用这个表达式，写在&lt;aop:aspect&gt;里面，就只有这个切面可以使用 配置通知 前置通知: 在切入点方法之前执行 后置通知: 在切入点方法正常执行之后执行(如果发生异常，则不会执行，和异常通知只能执行其中一个) 异常通知: 在切入点方法执行产生异常后执行 最终通知: 无论切入方法是否正常执行他都会在最后执行 环绕通知: &lt;aop:around method=&quot;aroundPrintLog&quot; pointcut-ref=&quot;pc1&quot;&gt;&lt;/aop:around&gt; 问题: 当我们配置了环绕通知之后，切入点方法没有执行，环绕通知却执行了 分析: 通过对比动态代理的的环绕通知的代码，发现动态代理中有明确的切入点方法调用，而我们的代码里没有 解决: Spring框架中为我们提供了ProceedingJoinPoint接口，里面有一个proceed()的方法，此方法就相当于明确调用切入点方法 Spring中的环绕通知就是框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式1234567891011121314151617public Object aroundPrintLog(ProceedingJoinPoint pjp){ Object rtValue = null; try { //得到方法执行所需要的参数 Object[] args = pjp.getArgs(); System.out.println(\"环绕通知Logger类中的aroundPrintLog方法开始记录日志了。。。。前置\"); // 明确调用切入点方法(业务层方法) rtValue = pjp.proceed(args); System.out.println(\"环绕通知Logger类中的aroundPrintLog方法开始记录日志了。。。。后置\"); return rtValue; } catch (Throwable t){ System.out.println(\"环绕通知Logger类中的aroundPrintLog方法开始记录日志了。。。。异常\"); throw new RuntimeException(t); } finally { System.out.println(\"环绕通知Logger类中的aroundPrintLog方法开始记录日志了。。。。最终\"); } } 示例bean.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--配置Spring的IOC，把Service对象配置进来--&gt; &lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;!--配置Logger类--&gt; &lt;bean id=\"logger\" class=\"com.xushui.utils.Logger\"&gt;&lt;/bean&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!--配置表达式标签--&gt; &lt;aop:pointcut id=\"pc1\" expression=\"execution(* com.xushui.service.Impl.*.*(..))\"&gt;&lt;/aop:pointcut&gt; &lt;!--配置切面--&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!--配置通知类型，并建立通知方法和切入点方法的关联--&gt; &lt;!--配置前置通知--&gt; &lt;aop:before method=\"beforePrintLog\" pointcut-ref=\"pc1\"&gt;&lt;/aop:before&gt; &lt;!--配置后置通知--&gt; &lt;aop:after-returning method=\"afterReturningPrintLog\" pointcut-ref=\"pc1\"&gt;&lt;/aop:after-returning&gt; &lt;!--配置异常通知--&gt; &lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut-ref=\"pc1\"&gt;&lt;/aop:after-throwing&gt; &lt;!--配置最终通知--&gt; &lt;aop:after method=\"afterPrintLog\" pointcut-ref=\"pc1\"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; Spring中基于注解的AOP配置配置Spring开启注解AOP的支持在bean.xml中添加这两句1234&lt;!--配置Spring创建容器时要扫描的包--&gt;&lt;context:component-scan base-package=\"com.xushui\"&gt;&lt;/context:component-scan&gt;&lt;!--配置Spring开启注解AOP的支持--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 注解 @Aspect 作用: 表示是一个切面类 通知注解 @Before(): 前置通知 @AfterReturning(): 后置通知 @AfterThrowing(): 异常通知 @After(): 最终通知 @Around(): 环绕通知 以上注解的value都为表达式 表达式注解 @Pointcut(): 写在方法上，方法名为id，value属性为表达式的内容。例如:execution(* com.xushui.service.Impl.*.*(..)) 基于注解方式配置的一个小问题后置通知和最终通知的调用顺序会出现问题，建议要用注解配置模式的话采用环绕通知。 完全不使用bean.xml的方法","link":"/2019/08/05/Spring学习笔记-4/"},{"title":"Spring学习笔记(2)","text":"基于注解的IOC配置创建对象作用与xml配置文件中的&lt;bean&gt;标签实现的功能是一样的 @Component: 作用: 用于把当前类对象存入Spring容器中 属性: value: 用于指定bean的id，默认值为当前类名(首字母改为小写) 以下三种作用和属性和@Component是一样的，是Spring框架提供的明确三层使用的注解。 @Controller: 一般用在表现层 @Service: 一般用在业务层 @Repository: 一般用在持久层 当三层都不属于的对象可以选择使用@Component 注入数据作用与在xml配置文件中&lt;bean&gt;标签里写一个&lt;property&gt;是一样的 @Autowired 作用: 按照类型注入，只要容器中有唯一的一个bean对象类型和注入的变量类型匹配，就能成功注入 如果IOC容器中没有任何bean的类型和要注入对象的类型匹配，则报错 如果IOC容器中有多个bean的类型和要注入对象匹配时: 被注入的对象和其中一个bean的名称相同时，可以将名字相同的注入 被注入的对象和所有的bean的名称不同时，会因为不知道选择哪个而报错 出现位置: 可以是变量上，也可以是方法上 细节: 使用注解注入，set方法不是必须的 @Qualifier 作用: 在按照类中注入的基础之上再按照名称注入，它在给成员变量注入时不能单独使用(要和@AutoWired注解一起使用)，但是在给方法参数注入时可以 属性: value: 用于指定注入bean的id 给方法使用的例子当有多个数据源可以使用时，你可以用@Qualifier注解添加你想要的那个，此时@Qualifier可以单独使用12345@Bean(\"runner\")@Scope(\"prototype\")public QueryRunner createQueryRunner(@Qualifier(\"dataSource1\") ComboPooledDataSource dataSource) { return new QueryRunner(dataSource);} @Resource 作用: 直接按照bean的id注入，可以独立使用 属性: name: 用于指定bean的id 以上三种注入方式都只能注入其他bean类型的数据，不能注入String和基本类型，其中集合类型的注入只能通过xml配置的方式实现 @Value 作用: 用于注入基本类型和String类型的数据 属性: value: 用于指定数据的值，它可以使用Spring中SpringEL表达式 作用范围作用与在&lt;bean&gt;标签中使用scope属性实现的功能是一样的 @Scope 作用:用于指定bean的作用范围 属性: value: 指定作用范围的取值 常用取值: singleton(默认): 单例 prototype: 多例 生命周期(了解)作用与&lt;bean&gt;标签中使用init-method和destroy-method的作用是一样的 @PostConstruct 作用: 用于指定初始化方法 @PreDestroy 作用: 用于指定销毁方法 实现注解IOC配置需要的操作告知Spring在创建容器时需要扫描的包，配置所需的标签不是在beans的约束中，而是一个叫context名称空间和约束中 为bean.xml添加约束(在Spring官方文档中搜索xmlns:context) 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 加入&lt;context:component-scan base-package=&quot;com.xushui&quot;&gt;&lt;/context:component-scan&gt;语句，来对指定目录的包进行扫描 引入注入数据12345678@Component(\"accountService\")public class AccountServiceImpl implements AccountService { //还未注入数据 private AccountDao accountDao = null; public void saveAccount() { accountDao.saveAccount(); }} 直接在测试类中调用方法，会有java.lang.NullPointerException(空指针异常)，所以我们还需要注入数据 Spring新注解@Configuration 作用: 指定当前类为配置类 细节: 当配置类作为AnnotationConfigApplicationContext方法的参数时，可以不写 @ComponentScan 作用: 用于通过注解指定Spring在创建容器时要扫描的包 属性: value: 他和basePackages的作用是一样的，等同于在xml里配置了&lt;context:component-scan base-package=&quot;com.xushui&quot;&gt;&lt;/context:component-scan&gt; @Bean 作用: 用于把当前方法的返回值作为bean对象存入到Spring的IOC容器中 属性: name: 用于指定bean的id，默认值是当前方法的名称 细节: 当我们使用注解配置方法时，如果方法有参数，Spring框架会去容器中查找有没有可用的bean对象 查找的方式和Autowired注解的作用是一样的 其他注解@Import 作用: 用于导入其他的配置类 属性: value: 用于指定其他配置类的字节码 有Import注解的配置类就为主配置类，而导入的都是子配置类 @PropertySource 作用: 用于指定properties文件的位置 属性: value: 指定文件的名称和路径 关键字: classpath，表示类路径下 小案例xml案例bean.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.xushui.service.Impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.xushui.dao.Impl.AccountDaoImpl\"&gt; &lt;property name=\"runner\" ref=\"queryRunner\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"queryRunner\" class=\"org.apache.commons.dbutils.QueryRunner\" scope=\"prototype\"&gt; &lt;constructor-arg name=\"ds\" ref=\"dateSource\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"dateSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"******\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在bean.xml中配置好后要通过ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);来加载配置文件 注解形式用了注解后，就不需要set方法，用AutoWired自动配置123456@Repository(\"accountDao\")public class AccountDaoImpl implements AccountDao { @Autowired private QueryRunner runner = null; ... 也可以使用resource注解指定bean对象的id123456@Repository(\"accountDao\")public class AccountDaoImpl implements AccountDao { @Resource(name = \"runner\") private QueryRunner runner = null; ... AccountService中也是一样12345@Service(\"accountService\")public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao = null; ... 最重要的是创建一个配置类123456789101112131415161718192021222324252627/** * 他是一个配置类，作用和bean.xml一样 * Configuration表示当前类就是配置类 */@Configuration@ComponentScan(\"com.xushui\")public class SpringConfiguration { @Bean(\"runner\") public QueryRunner createQueryRunner(ComboPooledDataSource dataSource) { return new QueryRunner(dataSource); } @Bean(\"dataSource\") public ComboPooledDataSource createDataSource() { try { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/spring\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"******\"); return dataSource; } catch (Exception e) { throw new RuntimeException(\"数据库连接初始化失败\"); } }} 当这些都具备了就可以不需要bean.xml了然后通过ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);来加载配置类 小优化此时当这些都完成了，还有一个要注意的地方是runner此时还是个单例的对象，线程不安全，添加注解@Scope(&quot;prototype&quot;)12345@Bean(\"runner\")@Scope(\"prototype\")public QueryRunner createQueryRunner(ComboPooledDataSource dataSource) { return new QueryRunner(dataSource);} 可以添加一个jdbc的配置类，用主配置文件加上@Improt注解的形式导入jdbc的配置类。同时加上@PropertySource将配置文件加载进来1234567891011@Import(JdbcConfig.class)@Configuration@ComponentScan(\"com.xushui\")@PropertySource(\"classpath:jdbc.properties\")public class SpringConfiguration { @Bean(\"runner\") @Scope(\"prototype\") public QueryRunner createQueryRunner(ComboPooledDataSource dataSource) { return new QueryRunner(dataSource); }} 用Spring的el表达式读取配置文件12345678910111213141516171819202122232425262728public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String username; @Value(\"${jdbc.password}\") private String password; @Bean(\"dataSource\") public ComboPooledDataSource createDataSource() { try { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource; } catch (Exception e) { throw new RuntimeException(\"数据库连接初始化失败\"); } }} Spring整合junit的配置 导入Spring整合junit的jar包(坐标) 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 使用junit提供的一个注解，把原有的main方法替换了，替换成Spring提供的@Runwith(SpringJunit4ClassRunner.class) 告知Spring的运行器，Spring和IOC的创建是基于xml还是注解的，并且说明位置 @ContextConfiguration locations: 指定xml文件的位置，加上classpath关键字，表示在类路径下 classes: 指定注解类所在的位置 在测试类中，就可以通过这几个注解，就可以不用自己导入配置类或配置文件，可以直接使用Spring的IOC容器中的对象123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class AccountServiceTest { @Autowired private AccountService accountService; ... 需要注意的是Spring5.x版本，只支持4.12版本以上的JUnit","link":"/2019/08/03/Spring学习笔记-2/"}],"tags":[{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[]}